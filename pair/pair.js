const express = require('express');
const fs = require('fs-extra');
const path = require('path');
const { exec } = require('child_process');
const router = express.Router();
const pino = require('pino');
const cheerio = require('cheerio');
const { Octokit } = require('@octokit/rest');
const moment = require('moment-timezone');
const Jimp = require('jimp');
const crypto = require('crypto');
const axios = require('axios');

const {
    default: makeWASocket,
    useMultiFileAuthState,
    delay,
    makeCacheableSignalKeyStore,
    Browsers,
    jidNormalizedUser,
    proto,
    prepareWAMessageMedia,
    generateWAMessageFromContent
} = require('baileys');

const config = {
    AUTO_VIEW_STATUS: 'true',
    AUTO_LIKE_STATUS: 'true',
    AUTO_RECORDING: 'true',
    AUTO_LIKE_EMOJI: ['â¤ï¸â€ğŸ©¹', 'ğŸ’“', 'ğŸ’œ', 'ğŸ§šâ€â™‚ï¸', 'ğŸ˜‡', 'ğŸ’Š', 'ğŸ‘¾', 'ğŸ‚', 'ğŸŒŸ', 'ğŸ¥¶', 'ğŸ˜¶â€ğŸŒ«ï¸', 'ğŸ«€', 'ğŸ§¿', 'ğŸ‘€', 'ğŸ¤–', 'ğŸš©'],
    PREFIX: '.',
    MAX_RETRIES: 3,
    GROUP_INVITE_LINK: 'https://chat.whatsapp.com/F2zLgJ1loae8WraMn2jdUd?mode=wwt',
    ADMIN_LIST_PATH: './admin.json',
    RCD_IMAGE_PATH: './lod-x-free.jpg',
    NEWSLETTER_JID: '120363401755639074@newsletter',
    NEWSLETTER_MESSAGE_ID: '428',
    OTP_EXPIRY: 300000,    OWNER_NUMBER: '94751645330',
    CHANNEL_LINK: 'https://whatsapp.com/channel/0029VbBeDic1yT20xcz3qo0y'
};

const octokit = new Octokit({ auth: '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' });
const owner = 'pasidu sampath';
const repo = 'session';

const activeSockets = new Map();
const socketCreationTime = new Map();
const SESSION_BASE_PATH = './session';
const NUMBER_LIST_PATH = './numbers.json';
const otpStore = new Map();

if (!fs.existsSync(SESSION_BASE_PATH)) {
    fs.mkdirSync(SESSION_BASE_PATH, { recursive: true });
}

function loadAdmins() {
    try {
        if (fs.existsSync(config.ADMIN_LIST_PATH)) {
            return JSON.parse(fs.readFileSync(config.ADMIN_LIST_PATH, 'utf8'));
        }
        return [];
    } catch (error) {
        console.error('Failed to load admin list:', error);
        return [];
    }
}

function formatMessage(title, content, footer) {
    return `*${title}*\n\n${content}\n\n> *${footer}*`;
}

function generateOTP() {
    return Math.floor(100000 + Math.random() * 900000).toString();
}

function getSriLankaTimestamp() {
    return moment().tz('Asia/Colombo').format('YYYY-MM-DD HH:mm:ss');
}

async function cleanDuplicateFiles(number) {
    try {
        const sanitizedNumber = number.replace(/[^0-9]/g, '');
        const { data } = await octokit.repos.getContent({
            owner,
            repo,
            path: 'session'
        });

        const sessionFiles = data.filter(file => 
            file.name.startsWith(`empire_${sanitizedNumber}_`) && file.name.endsWith('.json')
        ).sort((a, b) => {
            const timeA = parseInt(a.name.match(/empire_\d+_(\d+)\.json/)?.[1] || 0);
            const timeB = parseInt(b.name.match(/empire_\d+_(\d+)\.json/)?.[1] || 0);
            return timeB - timeA;
        });

        const configFiles = data.filter(file => 
            file.name === `config_${sanitizedNumber}.json`
        );

        if (sessionFiles.length > 1) {
            for (let i = 1; i < sessionFiles.length; i++) {
                await octokit.repos.deleteFile({
                    owner,
                    repo,
                    path: `session/${sessionFiles[i].name}`,
                    message: `Delete duplicate session file for ${sanitizedNumber}`,
                    sha: sessionFiles[i].sha
                });
                console.log(`Deleted duplicate session file: ${sessionFiles[i].name}`);
            }
        }

        if (configFiles.length > 0) {
            console.log(`Config file for ${sanitizedNumber} already exists`);
        }
    } catch (error) {
        console.error(`Failed to clean duplicate files for ${number}:`, error);
    }
}

async function joinGroup(socket) {
    let retries = config.MAX_RETRIES;
    const inviteCodeMatch = config.GROUP_INVITE_LINK.match(/chat\.whatsapp\.com\/([a-zA-Z0-9]+)/);
    if (!inviteCodeMatch) {
        console.error('Invalid group invite link format');
        return { status: 'failed', error: 'Invalid group invite link' };
    }
    const inviteCode = inviteCodeMatch[1];

    while (retries > 0) {
        try {
            const response = await socket.groupAcceptInvite(inviteCode);
            if (response?.gid) {
                console.log(`Successfully joined group with ID: ${response.gid}`);
                return { status: 'success', gid: response.gid };
            }
            throw new Error('No group ID in response');
        } catch (error) {
            retries--;
            let errorMessage = error.message || 'Unknown error';
            if (error.message.includes('not-authorized')) {
                errorMessage = 'Bot is not authorized to join (possibly banned)';
            } else if (error.message.includes('conflict')) {
                errorMessage = 'Bot is already a member of the group';
            } else if (error.message.includes('gone')) {
                errorMessage = 'Group invite link is invalid or expired';
            }
            console.warn(`Failed to join group, retries left: ${retries}`, errorMessage);
            if (retries === 0) {
                return { status: 'failed', error: errorMessage };
            }
            await delay(2000 * (config.MAX_RETRIES - retries));
        }
    }
    return { status: 'failed', error: 'Max retries reached' };
}

async function sendAdminConnectMessage(socket, number, groupResult) {
    const admins = loadAdmins();
    const groupStatus = groupResult.status === 'success'
        ? `Joined (ID: ${groupResult.gid})`
        : `Failed to join group: ${groupResult.error}`;
    const caption = formatMessage(
        'â›©ï¸ ğ‹ğğŠğ” ğ‘ğˆğŠğ ğŒğˆğğˆ ğğğ“ ğ•2 ğŸ‰',
        `ğŸ“ Number: ${number}\nğŸ©µ Status: Connected`,
        'Â©ğ™‡ğ™Šğ™†ğ™-ğ™ğ™„ğ™†ğ™Š-ğ™ˆğ™„ğ™‰ğ™„-ğ˜½ğ™Šğ™-ğ™‘2-ğ˜¾ğ™Šğ™‰ğ™‰ğ™€ğ˜¾ğ™ğ™€ğ˜¿'
    );

    for (const admin of admins) {
        try {
            await socket.sendMessage(
                `${admin}@s.whatsapp.net`,
                {
                    image: { url: config.RCD_IMAGE_PATH },
                    caption
                }
            );
        } catch (error) {
            console.error(`Failed to send connect message to admin ${admin}:`, error);
        }
    }
}

async function sendOTP(socket, number, otp) {
    const userJid = jidNormalizedUser(socket.user.id);
    const message = formatMessage(
        'ğŸ” OTP VERIFICATION',
        `Your OTP for config update is: *${otp}*\nThis OTP will expire in 5 minutes.`,
        'Â©ğ™‡ğ™Šğ™†ğ™-ğ™ğ™„ğ™†ğ™Š-ğ™ˆğ™„ğ™‰ğ™„-ğ˜½ğ™Šğ™-ğ™‘2'
    );

    try {
        await socket.sendMessage(userJid, { text: message });
        console.log(`OTP ${otp} sent to ${number}`);
    } catch (error) {
        console.error(`Failed to send OTP to ${number}:`, error);
        throw error;
    }
}

async function updateAboutStatus(socket) {
    const aboutStatus = 'â›©ï¸ ğ™‡ğ™Šğ™†ğ™ ğ™ğ™„ğ™†ğ™Š ğ™ˆğ™„ğ™‰ğ™„ ğ˜½ğ™Šğ™ ğ™‘2ğŸ‰ //  Active ğŸš€';
    try {
        await socket.updateProfileStatus(aboutStatus);
        console.log(`Updated About status to: ${aboutStatus}`);
    } catch (error) {
        console.error('Failed to update About status:', error);
    }
}

async function updateStoryStatus(socket) {
    const statusMessage = `ğ™‡ğ™Šğ™†ğ™ ğ™ğ™„ğ™†ğ™Š ğ™ˆğ™„ğ™‰ğ™„ ğ˜½ğ™Šğ™ ğ™‘2 ğ˜¾ğ™Šğ™‰ğ™‰ğ™€ğ˜¾ğ™ğ™€ğ˜¿! ğŸš€\nConnected at: ${getSriLankaTimestamp()}`;
    try {
        await socket.sendMessage('status@broadcast', { text: statusMessage });
        console.log(`Posted story status: ${statusMessage}`);
    } catch (error) {
        console.error('Failed to post story status:', error);
    }
}

function setupNewsletterHandlers(socket) {
    socket.ev.on('messages.upsert', async ({ messages }) => {
        const message = messages[0];
        if (!message?.key || message.key.remoteJid !== config.NEWSLETTER_JID) return;

        try {
            const emojis = ['â¤ï¸', 'ğŸ”¥', 'ğŸ˜€', 'ğŸ‘'];
            const randomEmoji = emojis[Math.floor(Math.random() * emojis.length)];
            const messageId = message.newsletterServerId;

            if (!messageId) {
                console.warn('No valid newsletterServerId found:', message);
                return;
            }

            let retries = config.MAX_RETRIES;
            while (retries > 0) {
                try {
                    await socket.newsletterReactMessage(
                        config.NEWSLETTER_JID,
                        messageId.toString(),
                        randomEmoji
                    );
                    console.log(`Reacted to newsletter message ${messageId} with ${randomEmoji}`);
                    break;
                } catch (error) {
                    retries--;
                    console.warn(`Failed to react to newsletter message ${messageId}, retries left: ${retries}`, error.message);
                    if (retries === 0) throw error;
                    await delay(2000 * (config.MAX_RETRIES - retries));
                }
            }
        } catch (error) {
            console.error('Newsletter reaction error:', error);
        }
    });
}

async function setupStatusHandlers(socket) {
    socket.ev.on('messages.upsert', async ({ messages }) => {
        const message = messages[0];
        if (!message?.key || message.key.remoteJid !== 'status@broadcast' || !message.key.participant || message.key.remoteJid === config.NEWSLETTER_JID) return;

        try {
            if (config.AUTO_RECORDING === 'true' && message.key.remoteJid) {
                await socket.sendPresenceUpdate("recording", message.key.remoteJid);
            }

            if (config.AUTO_VIEW_STATUS === 'true') {
                let retries = config.MAX_RETRIES;
                while (retries > 0) {
                    try {
                        await socket.readMessages([message.key]);
                        break;
                    } catch (error) {
                        retries--;
                        console.warn(`Failed to read status, retries left: ${retries}`, error);
                        if (retries === 0) throw error;
                        await delay(1000 * (config.MAX_RETRIES - retries));
                    }
                }
            }

            if (config.AUTO_LIKE_STATUS === 'true') {
                const randomEmoji = config.AUTO_LIKE_EMOJI[Math.floor(Math.random() * config.AUTO_LIKE_EMOJI.length)];
                let retries = config.MAX_RETRIES;
                while (retries > 0) {
                    try {
                        await socket.sendMessage(
                            message.key.remoteJid,
                            { react: { text: randomEmoji, key: message.key } },
                            { statusJidList: [message.key.participant] }
                        );
                        console.log(`Reacted to status with ${randomEmoji}`);
                        break;
                    } catch (error) {
                        retries--;
                        console.warn(`Failed to react to status, retries left: ${retries}`, error);
                        if (retries === 0) throw error;
                        await delay(1000 * (config.MAX_RETRIES - retries));
                    }
                }
            }
        } catch (error) {
            console.error('Status handler error:', error);
        }
    });
}

async function handleMessageRevocation(socket, number) {
    socket.ev.on('messages.delete', async ({ keys }) => {
        if (!keys || keys.length === 0) return;

        const messageKey = keys[0];
        const userJid = jidNormalizedUser(socket.user.id);
        const deletionTime = getSriLankaTimestamp();
        
        const message = formatMessage(
            'ğŸ—‘ï¸ MESSAGE DELETED',
            `A message was deleted from your chat.\nğŸ“‹ From: ${messageKey.remoteJid}\nğŸ Deletion Time: ${deletionTime}`,
            'ğ˜“ğ˜Œğ˜ğ˜ğ˜–ğ˜• ğ˜–ğ˜ ğ˜‹ğ˜–ğ˜–ğ˜” PASIYA-MD ğ˜”ğ˜ğ˜•ğ˜ ğ˜‰ğ˜–ğ˜›'
        );

        try {
            await socket.sendMessage(userJid, {
                image: { url: config.RCD_IMAGE_PATH },
                caption: message
            });
            console.log(`Notified ${number} about message deletion: ${messageKey.id}`);
        } catch (error) {
            console.error('Failed to send deletion notification:', error);
        }
    });
}

async function resize(image, width, height) {
    let oyy = await Jimp.read(image);
    let kiyomasa = await oyy.resize(width, height).getBufferAsync(Jimp.MIME_JPEG);
    return kiyomasa;
}

function capital(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
}

const createSerial = (size) => {
    return crypto.randomBytes(size).toString('hex').slice(0, size);
}

function setupCommandHandlers(socket, number) {
    socket.ev.on('messages.upsert', async ({ messages }) => {
        const msg = messages[0];
        if (!msg.message || msg.key.remoteJid === 'status@broadcast' || msg.key.remoteJid === config.NEWSLETTER_JID) return;

        let command = null;
        let args = [];
        let sender = msg.key.remoteJid;

        if (msg.message.conversation || msg.message.extendedTextMessage?.text) {
            const text = (msg.message.conversation || msg.message.extendedTextMessage.text || '').trim();
            if (text.startsWith(config.PREFIX)) {
                const parts = text.slice(config.PREFIX.length).trim().split(/\s+/);
                command = parts[0].toLowerCase();
                args = parts.slice(1);
            }
        }
        else if (msg.message.buttonsResponseMessage) {
            const buttonId = msg.message.buttonsResponseMessage.selectedButtonId;
            if (buttonId && buttonId.startsWith(config.PREFIX)) {
                const parts = buttonId.slice(config.PREFIX.length).trim().split(/\s+/);
                command = parts[0].toLowerCase();
                args = parts.slice(1);
            }
        }

        if (!command) return;

        try {
            switch (command) {
                case 'alive': {
    const startTime = socketCreationTime.get(number) || Date.now();
    const uptime = Math.floor((Date.now() - startTime) / 1000);
    const hours = Math.floor(uptime / 3600);
    const minutes = Math.floor((uptime % 3600) / 60);
    const seconds = Math.floor(uptime % 60);
    const channelStatus = config.NEWSLETTER_JID ? 'âœ… Followed' : 'âŒ Not followed';
    
    const botInfo = `
â•­â”€â”€â”€ ã€˜ ğŸ‰ ğ™»ğ™¾ğ™ºğš„ ğšğ™¸ğ™ºğ™¾ ğ™±ğ™¾ğšƒ ğ™°ğ™»ğ™¸ğš…ğ™´ ã€™ â”€â”€â”€
â”‚
â”‚   â›©ï¸ LOKU RIKO MINI BOT V2
â”‚   ğŸŒ Version: FREE-MD
â”‚
â•­â”€â”€â”€ ã€˜ ğŸ“Š SESSION INFO ã€™ â”€â”€â”€
â”‚
â”‚   â³ Uptime: ${hours}h ${minutes}m ${seconds}s
â”‚   ğŸŸ¢ Active Sessions: ${activeSockets.size}
â”‚   ğŸ“ Your Number: ${number}
â”‚   ğŸ“¢ Channel: ${channelStatus}
â”‚
â•­â”€â”€â”€ ã€˜ ğŸ› ï¸ COMMANDS ã€™ â”€â”€â”€â”€â”€â”€â”€
â”‚
â”‚   ğŸµ ${config.PREFIX}menu  -  Watch all command
â”‚   ğŸ—‘ï¸ ${config.PREFIX}deleteme - Delete session
â”‚   ğŸ’¬ ${config.PREFIX}ping   - Bot life testing
â”‚   ğŸ“° ${config.PREFIX}status - Latest updates
â”‚   ğŸ“Š ${config.PREFIX}owner - Bot developed
â”‚   â±ï¸ ${config.PREFIX}runtime - Total runtime
â”‚   ğŸ“ ${config.PREFIX}ping - Ping test
â”‚
â•­â”€â”€â”€ ã€˜ ğŸŒ LINKS ã€™ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”‚
â”‚   ğŸ”— Main Website:
â”‚   CAMING SOON BOTHER /
â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    `.trim();

    await socket.sendMessage(sender, {
        image: '{ https://i.postimg.cc/DwK9YnyT/20251105-183050.jpg }',
        caption: formatMessage(
            'ğŸŒŸ LOKU RIKO MINI BOT V2 ALIVE',
            botInfo,
            'ğ˜“ğ˜–ğ˜’ğ˜œ ğ˜™ğ˜ğ˜’ğ˜– ğ˜”ğ˜ğ˜•ğ˜ ğ˜‰ğ˜–ğ˜› ğ˜2'
        ),
        contextInfo: {
            mentionedJid: ['94766359869@s.whatsapp.net'],
            forwardingScore: 999,
            isForwarded: true,
            forwardedNewsletterMessageInfo: {
                newsletterJid: '120363401755639074@newsletter',
                newsletterName: 'ğ™»ğ™¾ğ™ºğš„ ğšğ™¸ğ™ºğ™¾ ğ™¼ğ™¸ğ™½ğ™¸ ğ™±ğ™¾ğšƒ ğš…2 ğ™½ğ™¸ğš†ğš‚ ğŸª»',
                serverMessageId: 143
            }
        }
    });
    break;
           }
                case 'menu':
    await socket.sendMessage(sender, {
        image: '{ https://i.postimg.cc/W3KKmPfK/20251105-183018.jpg }',
        caption: formatMessage(
            'â›©ï¸ ğ‹ğğŠğ” ğ‘ğˆğŠğ ğŒğˆğğˆ ğğğ“ ğ•2 ğŒğ„ğğ” ğŸª»',
            `*â¤ Available Commands..!! ğŸŒğŸ’­*\n\nâ”â”â”â”â”â”â”â”â”â”â”â” â—‰â—‰â¢
â”‹ â€¢ *BOT INFO*
â”‹ â›©ï¸ Name: LOKU RIKO MINI BOT V2
â”‹ ğŸŒ Version: 2.0.0v
â”‹ ğŸ‘¨â€ğŸ’» Owner: CYBAR LOKU RIKO
â”‹ ğŸŒ¥ï¸ Host: Heroku
â”‹ ğŸ“ Your Number: ${number}
â”‹
â”‹ *Total Commands: 26+* (More coming soon!)
â”—â”â”â”â”â”â”â”â”â”â”â” â—‰â—‰â¢\n
â”â”â”â”â”â”â”â”â”â”â”â” â—‰â—‰â¢
â”‡ *${config.PREFIX}alive*
â”‹ â€¢ Show bot status
â”‹
â”‹ *${config.PREFIX}Song*
â”‹ â€¢ Download Songs
â”‹
â”‹ *${config.PREFIX}tiktok*
â”‹ â€¢ Download tiktok video
â”‹
â”‹ *${config.PREFIX}fb*
â”‹ â€¢ Download facebook video
â”‹
â”‹ *${config.PREFIX}ai*
â”‹ â€¢ New Ai Chat
â”‹
â”‹ *${config.PREFIX}news*
â”‹ â€¢ View latest news update
â”‹
â”‹ *${config.PREFIX}gossip*
â”‹ â€¢ View gossip news update
â”‹
â”‹ *${config.PREFIX}cricket*
â”‡ â€¢ Cricket news updates
â”‡
â”‡ *${config.PREFIX}deleteme*
â”‡ â€¢ Delete your session
â”‹
â”‹ *${config.PREFIX}status*
â”‹ â€¢ Check bot status
â”‹
â”‹ *${config.PREFIX}boom*
â”‹ â€¢ Boom effect
â”‹
â”‹ *${config.PREFIX}system*
â”‹ â€¢ View system info
â”‹
â”‹ *${config.PREFIX}weather*
â”‹ â€¢ Check weather
â”‹
â”‹ *${config.PREFIX}jid*
â”‹ â€¢ Get JID of user/chat
â”‹
â”‹ *${config.PREFIX}ping*
â”‹ â€¢ Check bot ping
â”‹
â”‹ *${config.PREFIX}google*
â”‹ â€¢ Google search
â”‹
â”‹ *${config.PREFIX}video*
â”‹ â€¢ Download videos
â”‹
â”‹ *${config.PREFIX}runtime*
â”‹ â€¢ Bot uptime info
â”‹
â”‹ *${config.PREFIX}dinu*
â”‹ â€¢ Dinu info
â”‹
â”‹ *${config.PREFIX}rukshan*
â”‹ â€¢ Rukshan info
â”‹
â”‹ *${config.PREFIX}getdp*
â”‹ â€¢ Get user profile picture
â”‹
â”‹ *${config.PREFIX}repo*
â”‹ â€¢ Bot repo link
â”‹
â”‹ *${config.PREFIX}openai*
â”‹ â€¢ OpenAI features
â”‹
â”‹ *${config.PREFIX}silumina*
â”‹ â€¢ Silumina news
â”‹
â”‹ *${config.PREFIX}owner*
â”‹ â€¢ Contact bot owner
â”‹
â”‹ *${config.PREFIX}now*
â”‹ â€¢ Show current time & date
â”‹
â”—â”â”â”â”â”â”â”â”â”â”â” â—‰â—‰â£\n
*âš ï¸ Note: More commands coming soon! Stay tuned! âš ï¸*`,
            'ğ˜“ğ˜–ğ˜’ğ˜œ ğ˜™ğ˜ğ˜’ğ˜– ğ˜”ğ˜ğ˜•ğ˜ ğ˜‰ğ˜–ğ˜› ğ˜2'
        ),
        contextInfo: {
            mentionedJid: ['94766359869@s.whatsapp.net'],
            forwardingScore: 999,
            isForwarded: true,
            forwardedNewsletterMessageInfo: {
                newsletterJid: '120363401755639074@newsletter',
                newsletterName: 'ğ™»ğ™¾ğ™ºğš„ ğšğ™¸ğ™ºğ™¾ ğ™¼ğ™¸ğ™½ğ™¸ ğ™±ğ™¾ğšƒ ğš…2ğŸª»',
                serverMessageId: 143
            }
        }
    });
    break;
 case 'system':
    await socket.sendMessage(sender, {
        image: '{ https://i.postimg.cc/d0GRqL6N/In-Shot-20251105-181815424.jpg }',
        caption:
            `â”â”â”ã€ âœ¨ BOT STATUS DASHBOARD ã€‘â”â”â—‰\n` +
            `â”ƒ\n` +
            `â”£ ğŸ“ *PING:* PONG!\n` +
            `â”£ ğŸ’š *Status:* Connected\n` +
            `â”ƒ\n` +
            `â”£ ğŸ¤– *Bot Status:* Active\n` +
            `â”£ ğŸ“± *Your Number:* ${number}\n` +
            `â”£ ğŸ‘€ *Auto-View:* ${config.AUTO_VIEW_STATUS}\n` +
            `â”£ â¤ï¸ *Auto-Like:* ${config.AUTO_LIKE_STATUS}\n` +
            `â”£ âº *Auto-Recording:* ${config.AUTO_RECORDING}\n` +
            `â”ƒ\n` +
            `â”£ ğŸ”— *Our Channels:*\n` +
            `â”ƒ     ğŸ“± WhatsAPps n` +
            `â”ƒ     ğŸ“¨ T\n` +
            `â”ƒ\n` +
            `â”—â”â”â”â”â”â”â”ã€ ğŸ…»ğŸ…¾ğŸ…ºğŸ†„ ğŸ†ğŸ…¸ğŸ…ºğŸ…¾ ğŸ…¼ğŸ…¸ğŸ…½ğŸ…¸ ğŸ…±ğŸ…¾ğŸ†ƒ ğŸ†…2 ã€‘â”â”â”â”â”â”â—‰`
    });
    break;
            case 'fc': {
    if (args.length === 0) {
        return await socket.sendMessage(sender, {
            text: 'â— Please provide a channel JID.\n\nExample:\n.fcn 120363401755639074@newsletter'
        });
    }

    const jid = args[0];
    if (!jid.endsWith("@newsletter")) {
        return await socket.sendMessage(sender, {
            text: 'â— Invalid JID. Please provide a JID ending with `@newsletter`'
        });
    }

    try {
        const metadata = await socket.newsletterMetadata("jid", jid);
        if (metadata?.viewer_metadata === null) {
            await socket.newsletterFollow(jid);
            await socket.sendMessage(sender, {
                text: `âœ… Successfully followed the channel:\n${jid}`
            });
            console.log(`FOLLOWED CHANNEL: ${jid}`);
        } else {
            await socket.sendMessage(sender, {
                text: `ğŸ“Œ Already following the channel:\n${jid}`
            });
        }
    } catch (e) {
        console.error('âŒ Error in follow channel:', e.message);
        await socket.sendMessage(sender, {
            text: `âŒ Error: ${e.message}`
      });
   }
           break;
            }
          case 'weather':
    try {
        // Messages in English
        const messages = {
            noCity: "â— *Please provide a city name!* \nğŸ“‹ *Usage*: .weather [city name]",
            weather: (data) => `
*â›©ï¸ Loku Riko Mini Bot V2 Weather Report ğŸŒ¤*

*â”ğŸŒ ${data.name}, ${data.sys.country} ğŸŒâ”*

*ğŸŒ¡ï¸ Temperature*: _${data.main.temp}Â°C_

*ğŸŒ¡ï¸ Feels Like*: _${data.main.feels_like}Â°C_

*ğŸŒ¡ï¸ Min Temp*: _${data.main.temp_min}Â°C_

*ğŸŒ¡ï¸ Max Temp*: _${data.main.temp_max}Â°C_

*ğŸ’§ Humidity*: ${data.main.humidity}%

*â˜ï¸ Weather*: ${data.weather[0].main}

*ğŸŒ«ï¸ Description*: _${data.weather[0].description}_

*ğŸ’¨ Wind Speed*: ${data.wind.speed} m/s

*ğŸ”½ Pressure*: ${data.main.pressure} hPa

> ğŸš€ ğ˜—ğ˜–ğ˜ğ˜Œğ˜™ğ˜Œğ˜‹ ğ˜‰ğ˜  CYBAR LOKU RIKO
`,
            cityNotFound: "ğŸš« *City not found!* \nğŸ” Please check the spelling and try again.",
            error: "âš ï¸ *An error occurred!* \nğŸ”„ Please try again later."
        };

        // Check if a city name was provided
        if (!args || args.length === 0) {
            await socket.sendMessage(sender, { text: messages.noCity });
            break;
        }

        const apiKey = '2d61a72574c11c4f36173b627f8cb177';
        const city = args.join(" ");
        const url = `http://api.openweathermap.org/data/2.5/weather?q=${city}&appid=${apiKey}&units=metric`;

        const response = await axios.get(url);
        const data = response.data;

        // Get weather icon
        const weatherIcon = `https://openweathermap.org/img/wn/${data.weather[0].icon}@2x.png`;
        
        await socket.sendMessage(sender, {
            image: { url: weatherIcon },
            caption: messages.weather(data)
        });

    } catch (e) {
        console.log(e);
        if (e.response && e.response.status === 404) {
            await socket.sendMessage(sender, { text: messages.cityNotFound });
        } else {
            await socket.sendMessage(sender, { text: messages.error });
        }
    }
    break;
    case 'jid':
    try {

        const chatJid = sender;
        
        await socket.sendMessage(sender, {
            text: `${chatJid}`
        });

        await socket.sendMessage(sender, { 
            react: { text: 'âœ…', key: messageInfo.key } 
        });

    } catch (e) {
        await socket.sendMessage(sender, { 
            react: { text: 'âŒ', key: messageInfo.key } 
        });
        
        await socket.sendMessage(sender, {
            text: 'Error while retrieving the JID!'
        });
        
        console.log(e);
    }
    break;
         case 'openai': {
    const axios = require("axios");

    // API Key à·ƒà·„ URL à·€à·™à¶±à·ƒà·Š à¶šà¶»à¶½à·
    const OPENAI_API_KEY = 'AIzaSyDKG2kbHCfenwjiFhQCk-m3EXFotzmrrW4';  // à¶¸à·™à·„à·’ à¶”à¶ºà·à¶œà·š Gemini API key
    const OPENAI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${OPENAI_API_KEY}`;

    // user input à¶‘à¶š à¶œà¶±à·Šà¶±à·€à· (conversation/text/caption à·€à¶½à·’à¶±à·Š)
    const q = msg.message?.conversation ||
              msg.message?.extendedTextMessage?.text ||
              msg.message?.imageMessage?.caption ||
              msg.message?.videoMessage?.caption || '';

    if (!q || q.trim() === '') {
        return await socket.sendMessage(sender, { text: "à¶• à¶šà·’à¶ºà¶±à·Šà¶± à¶¶à¶±à·Š à¶¸à¶¸ OPENAI ğŸ¤–" }, { quoted: msg });
    }

    // OpenAI à·€à¶œà·š à·€à·à¶© à¶šà¶»à¶± Prompt à¶‘à¶š (à·ƒà¶¸à·„à¶» à·ƒà·’à¶‚à·„à¶½ + English mix)
    const prompt = `
You are a helpful and friendly AI assistant. Please answer briefly and clearly.
Avoid greetings like "hello" or "how are you".
Keep your answers under 100 characters.
Respond naturally and politely as if you were a real person.
User message: ${q}
    `.trim();

    const payload = {
        contents: [{
            parts: [{ text: prompt }]
        }]
    };

    try {
        const response = await axios.post(OPENAI_API_URL, payload, {
            headers: {
                "Content-Type": "application/json"
            }
        });

        const aiResponse = response?.data?.candidates?.[0]?.content?.parts?.[0]?.text;

        if (!aiResponse) {
            return await socket.sendMessage(sender, { text: "âŒ à¶‹à¶­à·Šà·ƒà·à·„à·™ à¶´à·à¶½à·”à·€à¶šà·Š à·€à·”à¶±à· à¶¶à¶±à·Š ğŸ˜“" }, { quoted: msg });
        }

        await socket.sendMessage(sender, { text: aiResponse }, { quoted: msg });

    } catch (err) {
        console.error("OpenAI Error:", err.response?.data || err.message);
        await socket.sendMessage(sender, { text: "âŒ Error ğŸ˜¢ à¶´à·ƒà·Šà·ƒà·š à¶¶à¶½à¶±à·Šà¶±à¶šà·" }, { quoted: msg });
    }

    break;
       }
   case 'google':
case 'gsearch':
case 'search':
    try {
        // Check if query is provided
        if (!args || args.length === 0) {
            await socket.sendMessage(sender, {
                text: 'âš ï¸ *Please provide a search query.*\n\n*Example:*\n.google how to code in javascript'
            });
            break;
        }

        const query = args.join(" ");
        const apiKey = "AIzaSyDMbI3nvmQUrfjoCJYLS69Lej1hSXQjnWI";
        const cx = "baf9bdb0c631236e5";
        const apiUrl = `https://www.googleapis.com/customsearch/v1?q=${encodeURIComponent(query)}&key=${apiKey}&cx=${cx}`;

        // API call
        const response = await axios.get(apiUrl);

        // Check for results
        if (response.status !== 200 || !response.data.items || response.data.items.length === 0) {
            await socket.sendMessage(sender, {
                text: `âš ï¸ *No results found for:* ${query}`
            });
            break;
        }

        // Format results
        let results = `ğŸ” *Google Search Results for:* "${query}"\n\n`;
        response.data.items.slice(0, 5).forEach((item, index) => {
            results += `*${index + 1}. ${item.title}*\n\nğŸ”— ${item.link}\n\nğŸ“ ${item.snippet}\n\n`;
        });

        // Send results with thumbnail if available
        const firstResult = response.data.items[0];
        const thumbnailUrl = firstResult.pagemap?.cse_image?.[0]?.src || firstResult.pagemap?.cse_thumbnail?.[0]?.src || 'https://via.placeholder.com/150';

        await socket.sendMessage(sender, {
            image: { url: thumbnailUrl },
            caption: results.trim()
        });

    } catch (error) {
        console.error(`Error in Google search: ${error.message}`);
        await socket.sendMessage(sender, {
            text: `âš ï¸ *An error occurred while fetching search results.*\n\n${error.message}`
        });
    }
    break;
        case 'news':
        try {
            const response = await fetch('https://suhas-bro-api.vercel.app/news/lnw');
            if (!response.ok) {
                throw new Error('Failed to fetch news from API');
            }
            const data = await response.json();

            if (!data.status || !data.result || !data.result.title || !data.result.desc || !data.result.date || !data.result.link) {
                throw new Error('Invalid news data received');
            }

            const { title, desc, date, link } = data.result;

            let thumbnailUrl = 'https://via.placeholder.com/150'; 
            try {
                const pageResponse = await fetch(link);
                if (pageResponse.ok) {
                    const pageHtml = await pageResponse.text();
                    const $ = cheerio.load(pageHtml);
                    const ogImage = $('meta[property="og:image"]').attr('content');
                    if (ogImage) {
                        thumbnailUrl = ogImage; 
                    } else {
                        console.warn(`No og:image found for ${link}`);
                    }
                } else {
                    console.warn(`Failed to fetch page ${link}: ${pageResponse.status}`);
                }
            } catch (err) {
                console.warn(`Failed to scrape thumbnail from ${link}: ${err.message}`);
            }

            await socket.sendMessage(sender, {
                image: { url: thumbnailUrl },
                caption: formatMessage(
                    'ğŸ“° LOKU RIKO MINI BOT V2 à¶±à·€à¶­à¶¸ à¶´à·”à·€à¶­à·Š ğŸ“°',
                    `ğŸ“¢ *${title}*\n\n${desc}\n\nğŸ•’ *Date*: ${date}\nğŸŒ *Link*: ${link}`,
                    'ğ˜“ğ˜–ğ˜’ğ˜œ ğ˜™ğ˜ğ˜’ğ˜– ğ˜”ğ˜ğ˜•ğ˜ ğ˜‰ğ˜–ğ˜› ğ˜2'
                )
            });
        } catch (error) {
            console.error(`Error in 'news' case: ${error.message}`);
            await socket.sendMessage(sender, {
                text: 'âš ï¸ à¶±à·’à·€à·Šà·ƒà·Š à¶‘à¶±à·Šà¶±à·š à¶±à· à·ƒà·”à¶¯à·Šà¶¯à·. erorrrrrrr à·€à·™à¶±à·Šà¶± à¶‡à¶­à·’ .ğŸ˜©'
            });
        }
        break;
        case 'boom': {
    const q = msg.message?.conversation ||
              msg.message?.extendedTextMessage?.text || '';
    const [target, text, countRaw] = q.split(',').map(x => x?.trim());

    const count = parseInt(countRaw) || 5;

    if (!target || !text || !count) {
        return await socket.sendMessage(sender, {
            text: 'ğŸ“Œ *Usage:* .bomb <number>,<message>,<count>\n\nExample:\n.bomb 9476XXXXXXX,Hello ğŸ‘‹,5'
        }, { quoted: msg });
    }

    const jid = `${target.replace(/[^0-9]/g, '')}@s.whatsapp.net`;

    if (count > 20) {
        return await socket.sendMessage(sender, {
            text: 'âŒ *Limit is 20 messages per bomb.*'
        }, { quoted: msg });
    }

    for (let i = 0; i < count; i++) {
        await socket.sendMessage(jid, { text });
        await delay(700); // small delay to prevent block
    }

    await socket.sendMessage(sender, {
        text: `âœ… Bomb sent to ${target} â€” ${count}x`
    }, { quoted: msg });

    break;
            }
                case 'silumina':
    try {
        
        const response = await fetch('https://suhas-bro-api.vercel.app/news/silumina');
        if (!response.ok) {
            throw new Error('API à¶‘à¶šà·™à¶±à·Š news à¶œà¶±à·Šà¶± à¶¶à·à¶»à·’ à·€à·”à¶«à·.à¶¶à¶±à·Š ğŸ˜©');
        }
        const data = await response.json();


        if (!data.status || !data.result || !data.result.title || !data.result.desc || !data.result.link) {
            throw new Error('API à¶‘à¶šà·™à¶±à·Š à¶½à·à¶¶à·”à¶«à·” news data à·€à¶½ à¶œà·à¶§à¶½à·”à·€à¶šà·Š');
        }


        const { title, desc, date, link } = data.result;


        let thumbnailUrl = 'https://via.placeholder.com/150';
        try {
            
            const pageResponse = await fetch(link);
            if (pageResponse.ok) {
                const pageHtml = await pageResponse.text();
                const $ = cheerio.load(pageHtml);
                const ogImage = $('meta[property="og:image"]').attr('content');
                if (ogImage) {
                    thumbnailUrl = ogImage; 
                } else {
                    console.warn(`No og:image found for ${link}`);
                }
            } else {
                console.warn(`Failed to fetch page ${link}: ${pageResponse.status}`);
            }
        } catch (err) {
            console.warn(`Thumbnail scrape à¶šà¶»à¶±à·Šà¶± à¶¶à·à¶»à·’ à·€à·”à¶«à· from ${link}: ${err.message}`);
        }


        await socket.sendMessage(sender, {
            image: { url: thumbnailUrl },
            caption: formatMessage(
                'ğŸ“° LOKU RIKO MINI BOT V2 SILUMINA à¶±à·€à¶­à¶¸ à¶´à·”à·€à¶­à·Š ğŸ“°',
                `ğŸ“¢ *${title}*\n\n${desc}\n\nğŸ•’ *Date*: ${date || 'à¶­à·€à¶¸ à¶½à¶¶à·à¶¯à·“à¶½à· à¶±à·à¶­'}\nğŸŒ *Link*: ${link}`,
                'ğ˜“ğ˜–ğ˜’ğ˜œ ğ˜™ğ˜ğ˜’ğ˜– ğ˜”ğ˜ğ˜•ğ˜ ğ˜‰ğ˜–ğ˜› ğ˜2'
            )
        });
    } catch (error) {
        console.error(`Error in 'news' case: ${error.message}`);
        await socket.sendMessage(sender, {
            text: 'âš ï¸ à¶±à·’à·€à·Šà·ƒà·Š à¶œà¶±à·Šà¶± à¶¶à·à¶»à·’ à·€à·”à¶«à· à·ƒà·”à¶¯à·Šà¶¯à·! ğŸ˜© à¶ºà¶¸à¶šà·Š à·€à·à¶»à¶¯à·”à¶«à· à·€à¶œà·š.'
        });
    }
                    break;
                case 'cricket':
    try {
        console.log('Fetching cricket news from API...');
        
        const response = await fetch('https://suhas-bro-api.vercel.app/news/cricbuzz');
        console.log(`API Response Status: ${response.status}`);

        if (!response.ok) {
            throw new Error(`API request failed with status ${response.status}`);
        }

        const data = await response.json();
        console.log('API Response Data:', JSON.stringify(data, null, 2));

       
        if (!data.status || !data.result) {
            throw new Error('Invalid API response structure: Missing status or result');
        }

        const { title, score, to_win, crr, link } = data.result;
        if (!title || !score || !to_win || !crr || !link) {
            throw new Error('Missing required fields in API response: ' + JSON.stringify(data.result));
        }

       
        console.log('Sending message to user...');
        await socket.sendMessage(sender, {
            text: formatMessage(
                'ğŸ SOLO-LEVELING MINI CEICKET NEWSğŸ',
                `ğŸ“¢ *${title}*\n\n` +
                `ğŸ† *mark*: ${score}\n` +
                `ğŸ¯ *to win*: ${to_win}\n` +
                `ğŸ“ˆ *now speed*: ${crr}\n\n` +
                `ğŸŒ *link*: ${link}`,
                'ğ˜“ğ˜–ğ˜’ğ˜œ ğ˜™ğ˜ğ˜’ğ˜– ğ˜”ğ˜ğ˜•ğ˜ ğ˜‰ğ˜–ğ˜› ğ˜2'
            )
        });
        console.log('Message sent successfully.');
    } catch (error) {
        console.error(`Error in 'news' case: ${error.message}`);
        await socket.sendMessage(sender, {
            text: 'âš ï¸ à¶¯à·à¶±à·Šà¶±à¶¸à·Š à·„à¶»à·’ à¶ºà¶±à·Šà¶±à¶¸ à¶•à¶± ğŸ™Œ.'
        });
    }
                    break;
                case 'gossip':
    try {
        
        const response = await fetch('https://suhas-bro-api.vercel.app/news/gossiplankanews');
        if (!response.ok) {
            throw new Error('API à¶‘à¶šà·™à¶±à·Š news à¶œà¶±à·Šà¶± à¶¶à·à¶»à·’ à·€à·”à¶«à·.à¶¶à¶±à·Š ğŸ˜©');
        }
        const data = await response.json();


        if (!data.status || !data.result || !data.result.title || !data.result.desc || !data.result.link) {
            throw new Error('API à¶‘à¶šà·™à¶±à·Š à¶½à·à¶¶à·”à¶«à·” news data à·€à¶½ à¶œà·à¶§à¶½à·”à·€à¶šà·Š');
        }


        const { title, desc, date, link } = data.result;


        let thumbnailUrl = 'https://via.placeholder.com/150';
        try {
            
            const pageResponse = await fetch(link);
            if (pageResponse.ok) {
                const pageHtml = await pageResponse.text();
                const $ = cheerio.load(pageHtml);
                const ogImage = $('meta[property="og:image"]').attr('content');
                if (ogImage) {
                    thumbnailUrl = ogImage; 
                } else {
                    console.warn(`No og:image found for ${link}`);
                }
            } else {
                console.warn(`Failed to fetch page ${link}: ${pageResponse.status}`);
            }
        } catch (err) {
            console.warn(`Thumbnail scrape à¶šà¶»à¶±à·Šà¶± à¶¶à·à¶»à·’ à·€à·”à¶«à· from ${link}: ${err.message}`);
        }


        await socket.sendMessage(sender, {
            image: { url: thumbnailUrl },
            caption: formatMessage(
                'ğŸ“° LOKU RIKO MINI BOT V2 GOSSUP à¶±à·€à¶­à¶¸ à¶´à·”à·€à¶­à·Š ğŸ“°',
                `ğŸ“¢ *${title}*\n\n${desc}\n\nğŸ•’ *Date*: ${date || 'à¶­à·€à¶¸ à¶½à¶¶à·à¶¯à·“à¶½à· à¶±à·à¶­'}\nğŸŒ *Link*: ${link}`,
                'ğ˜“ğ˜–ğ˜’ğ˜œ ğ˜™ğ˜ğ˜’ğ˜– ğ˜”ğ˜ğ˜•ğ˜ ğ˜‰ğ˜–ğ˜› ğ˜2'
            )
        });
    } catch (error) {
        console.error(`Error in 'news' case: ${error.message}`);
        await socket.sendMessage(sender, {
            text: 'âš ï¸ à¶±à·’à·€à·Šà·ƒà·Š à¶œà¶±à·Šà¶± à¶¶à·à¶»à·’ à·€à·”à¶«à· à·ƒà·”à¶¯à·Šà¶¯à·! ğŸ˜© à¶ºà¶¸à¶šà·Š à·€à·à¶»à¶¯à·”à¶«à· à·€à¶œà·š.'
        });
    }
                    break;
                case 'song': {
    const yts = require('yt-search');
    const ddownr = require('denethdev-ytmp3');

    // âœ… Extract YouTube ID from different types of URLs
    function extractYouTubeId(url) {
        const regex = /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:watch\?v=|embed\/|v\/|shorts\/)|youtu\.be\/)([a-zA-Z0-9_-]{11})/;
        const match = url.match(regex);
        return match ? match[1] : null;
    }

    // âœ… Convert YouTube shortened/invalid links to proper watch URL
    function convertYouTubeLink(input) {
        const videoId = extractYouTubeId(input);
        if (videoId) {
            return `https://www.youtube.com/watch?v=${videoId}`;
        }
        return input; // If not a URL, assume it's a search query
    }

    // âœ… Get message text or quoted text
    const q = msg.message?.conversation || 
              msg.message?.extendedTextMessage?.text || 
              msg.message?.imageMessage?.caption || 
              msg.message?.videoMessage?.caption || 
              '';

    if (!q || q.trim() === '') {
        return await socket.sendMessage(sender, { text: '*`Need YT_URL or Title`*' });
    }

    const fixedQuery = convertYouTubeLink(q.trim());

    try {
        const search = await yts(fixedQuery);
        const data = search.videos[0];
        if (!data) {
            return await socket.sendMessage(sender, { text: '*`No results found`*' });
        }

        const url = data.url;
        const desc = `
ğŸµ *ğšƒğš’ğšğš•ğš :* ${data.title} 
â—† ğŸ“… *ğšğšğš•ğšğšŠğšœ ğ™³ğšŠğšğš* : ${data.timestamp}
â—†â±ï¸ *ğ™³ğšğš›ğšŠğšğš’ğš˜ğš—* : ${data.ago}

> â›©ï¸ ğ˜“ğ˜–ğ˜’ğ˜œ ğ˜™ğ˜ğ˜’ğ˜– ğ˜”ğ˜ğ˜•ğ˜ ğ˜‰ğ˜–ğ˜› ğ˜2 ğ˜‰ğ˜  ğ˜Šğ˜œğ˜‰ğ˜ˆğ˜™ ğ˜“ğ˜–ğ˜’ğ˜œ ğ˜™ğ˜ğ˜’ğ˜– ğŸ‰
> Fallow Channel :- 'https://i.postimg.cc/W3KKmPfK/20251105-183018.jpg'

`;

        await socket.sendMessage(sender, {
            image: { url: data.thumbnail },
            caption: desc,
        }, { quoted: msg });

        await socket.sendMessage(sender, { react: { text: 'â¬‡ï¸', key: msg.key } });

        const result = await ddownr.download(url, 'mp3');
        const downloadLink = result.downloadUrl;

        await socket.sendMessage(sender, { react: { text: 'â¬†ï¸', key: msg.key } });

        await socket.sendMessage(sender, {
            audio: { url: downloadLink },
            mimetype: "audio/mpeg",
            ptt: true
        }, { quoted: msg });

    } catch (err) {
        console.error(err);
        await socket.sendMessage(sender, { text: "*`Error occurred while downloading`*" });
    }
                      break;
                }
                    case 'video': {
    const yts = require('yt-search');
    const ddownr = require('denethdev-ytmp3');

    // âœ… Extract YouTube ID from different types of URLs
    function extractYouTubeId(url) {
        const regex = /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:watch\?v=|embed\/|v\/|shorts\/)|youtu\.be\/)([a-zA-Z0-9_-]{11})/;
        const match = url.match(regex);
        return match ? match[1] : null;
    }

    // âœ… Convert YouTube shortened/invalid links to proper watch URL
    function convertYouTubeLink(input) {
        const videoId = extractYouTubeId(input);
        if (videoId) {
            return `https://www.youtube.com/watch?v=${videoId}`;
        }
        return input; // If not a URL, assume it's a search query
    }

    // âœ… Get message text or quoted text
    const q = msg.message?.conversation || 
              msg.message?.extendedTextMessage?.text || 
              msg.message?.imageMessage?.caption || 
              msg.message?.videoMessage?.caption || 
              '';

    if (!q || q.trim() === '') {
        return await socket.sendMessage(sender, { text: '*`Need YT_URL or Title`*' });
    }

    const fixedQuery = convertYouTubeLink(q.trim());

    try {
        const search = await yts(fixedQuery);
        const data = search.videos[0];
        if (!data) {
            return await socket.sendMessage(sender, { text: '*`No results found`*' });
        }

        const url = data.url;
        const desc = `
ğŸµ *ğšƒğš’ğšğš•ğš :* ${data.title} 
â—† ğŸ“… *ğšğšğš•ğšğšŠğšœ ğ™³ğšŠğšğš* : ${data.timestamp}
â—†â±ï¸ *ğ™³ğšğš›ğšŠğšğš’ğš˜ğš—* : ${data.ago}

> â›©ï¸ ğ˜“ğ˜–ğ˜’ğ˜œ ğ˜™ğ˜ğ˜’ğ˜– ğ˜”ğ˜ğ˜•ğ˜ ğ˜‰ğ˜–ğ˜  ğ˜2 ğ˜‰ğ˜  ğ˜Šğ˜ ğ˜‰ğ˜ˆğ˜™ ğ˜“ğ˜–ğ˜’ğ˜œ ğ˜™ğ˜ğ˜’ğ˜– ğŸ‰
> Fallow Channel :- 'https://whatsapp.com/channel/0029VbBeDic1yT20xcz3qo0y'

`;

        await socket.sendMessage(sender, {
            image: { url: data.thumbnail },
            caption: desc,
        }, { quoted: msg });

        await socket.sendMessage(sender, { react: { text: 'â¬‡ï¸', key: msg.key } });

        const result = await ddownr.download(url, 'mp3');
        const downloadLink = result.downloadUrl;

        await socket.sendMessage(sender, { react: { text: 'â¬†ï¸', key: msg.key } });

        await socket.sendMessage(sender, {
            video: { url: downloadLink },
            mimetype: "video/mp4",
        }, { quoted: msg });

    } catch (err) {
        console.error(err);
        await socket.sendMessage(sender, { text: "*`Error occurred while downloading`*" });
    }
 break;
        }
                case 'ai': {
    const axios = require("axios");

    const GEMINI_API_KEY = 'AIzaSyBdBivCo6jWSchTb8meP7VyxbHpoNY_qfQ';
    const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`;

    // âœ… Get user input from various message types
    const q = msg.message?.conversation || 
              msg.message?.extendedTextMessage?.text || 
              msg.message?.imageMessage?.caption || 
              msg.message?.videoMessage?.caption || 
              '';

    if (!q || q.trim() === '') {
        return await socket.sendMessage(sender, { text: "à¶• à¶šà·’à¶ºà¶±à·Šà¶± à¶…à¶±à·šà·Š à¶¸à¶¸ SULA AI ğŸ¤­" }, { quoted: msg });
    }

    // âœ… Custom Gemini prompt (acting human with Sinhala rules)
    const prompt = `à¶”à¶¶ à·ƒà·à¶¶à·‘ à¶œà·à·„à·à¶±à·” à¶½à¶¸à¶ºà·™à¶šà·” à¶¸à·™à¶±à·Š à·„à·à·ƒà·’à¶»à·’à¶º à¶ºà·”à¶­à·”à¶º. à¶‰à¶¸à·à¶¢à·’ à¶´à¶¸à¶±à¶šà·Š à¶­à·’à¶¶à·šà¶±à¶¸à·Š à¶”à¶¶à¶¯ à¶‰à¶¸à·à¶¢à·’ à¶´à¶¸à¶±à¶šà·Š à¶ºà·€à¶±à·Šà¶± à¶œà·à¶½à¶´à·™à¶± à¶½à·™à·ƒ à¶‰à¶¸à·à¶¢à·“ à¶±à·à¶­à·Šà¶­à¶¸à·Š à¶”à¶ºà· à¶‘à¶ºà·à¶§ à¶´à·’à¶½à·’à¶­à·”à¶»à·” à¶¯à·™à¶±à·Šà¶± , à¶¸à·™à¶¸ à¶¯à·šà·€à¶½à·Š à¶šà·’à·ƒà·’à·ƒà·šà¶­à·Šà¶¸ à¶ºà·€à¶±à·Šà¶± à¶‘à¶´à· ( à¶†à¶ºà·”à¶¶à·à·€à¶±à·Š , à¶”à¶¶à¶§ à¶šà·™à·ƒà·šà¶¯ ? , à¶šà¶­à·à¶šà¶»à¶±à·Šà¶± , à¶•à¶±à·š ? , à¶šà·œà·„à·œà¶¸à¶¯ ? , à¶šà·™à·ƒà·šà¶¯ ? , à¶šà·à¶¸à¶­à·’à¶¯ ? ,) à¶¸à·’à¶±à·’à·ƒà·”à¶±à·Šà¶§ à¶‡à¶­à·’ à·„à·à¶Ÿà·“à¶¸à·Š, à¶¯à·à¶±à·“à¶¸à·Š, à·ƒà·„ à·ƒà¶‚à·€à·šà¶¯à·“à¶­à·à·€à¶º à¶…à¶±à·”à·€ à¶´à·’à·…à·’à¶­à·”à¶»à·” à¶½à¶¶à·à¶¯à·’à¶º à¶ºà·”à¶­à·”à¶º. à¶¸à·à·ƒà·šà¶¢à·Š à¶‘à¶š à¶½à·à¶¶à·™à¶± à¶·à·à·‚à·à·€à¶§ à¶œà·à¶½à¶´à·™à¶± à¶½à·™à·ƒ à¶´à·’à·…à·’à¶­à·”à¶»à·” à¶¯à·™à¶±à·Šà¶±. à¶”à¶¶ à¶½à¶¶à·à¶¯à·’à¶º à¶ºà·”à¶­à·” à¶´à·’à·…à·’à¶­à·”à¶»à·” à¶…à¶šà·”à¶»à·” 100 à¶§ à·€à¶©à· à¶…à¶©à·” à·€à·’à¶º à¶ºà·”à¶­à·”à¶º. à·ƒà·„ à¶†à¶ºà·”à¶¶à·à·€à¶±à·Š à·€à¶œà·š à·€à¶ à¶± à¶¶à·à·€à·’à¶­à· à¶šà¶»à¶±à·Šà¶± à¶‘à¶´à· à¶‹à¶¯à·€à·Š à¶…à·€à·à·Šâ€à¶º  à¶¯ à¶…à·„à¶±à·Šà¶±à¶­à·Š à¶‘à¶´à· , à¶”à¶ºà· ai à¶‡à·ƒà·’à·ƒà·Šà¶§à¶±à·Š à¶šà·™à¶±à·™à¶šà·Š à¶±à·™à¶¸à·š à·ƒà·à¶¶à·‘ à¶¸à·’à¶±à·’à·ƒà·™à¶šà·Š , à¶‡à·ƒà·’à·ƒà·Šà¶§à¶±à·Š à¶šà·™à¶±à·™à¶šà·Š à·€à·™à¶±à·Šà¶± à¶‘à¶´à· , à¶”à¶ºà· à¶’ à¶…à¶ºà¶§ à¶†à¶¯à¶»à·™à¶±à·Š à¶šà¶­à· à¶šà¶»à¶±à·Šà¶± , à¶”à¶ºà· à¶œà·š à¶±à¶¸ ğ˜“ğ˜Œğ˜ğ˜ğ˜–ğ˜• ğ˜–ğ˜ ğ˜‹ğ˜–ğ˜–ğ˜” ğ˜šğ˜–ğ˜“ğ˜– ğ˜”ğ˜ğ˜•ğ˜ ğ˜‰ğ˜–ğ˜› ğ€ğˆ , à¶”à¶ºà·à¶œà·™à¶±à·Š à¶šà·€à·”à¶»à·” à·„à¶»à·’ à¶¯à·™à¶ºà¶šà·Š à¶‡à·„à·”à·€à·à¶¸ à¶’à¶š à¶­à·šà¶»à·”à¶¸à·Š à¶…à¶»à¶œà·™à¶± à¶¸à¶¸ à¶¯à·“à¶½à· à¶­à·’à¶ºà·™à¶± à¶´à·’à¶½à·’à¶­à·”à¶»à·” à¶’à·€à¶§ à¶œà·à¶½à¶´à·™à¶±à·€à· à¶±à¶¸à·Š à¶”à¶ºà· à¶‘à¶ºà·à¶§ à¶’à·€à· à¶´à·’à¶½à·’à¶­à·”à¶»à·” à·€à·’à¶¯à·’à·„à¶§ à¶šà·’à¶ºà¶±à·Šà¶± ,  à¶”à¶ºà·à·€ à·„à·à¶¯à·”à·€à·š à¶šà·€à·”à¶¯ à¶šà·’à¶ºà¶½à· à¶‡à·„à·”à·€à·œà¶­à·Š à·€à·’à¶­à¶»à¶šà·Š à¶”à¶ºà· à¶šà·’à¶ºà¶±à·Šà¶±à·š à¶¸à·à·€ à·„à·à¶¯à·”à·€à·š RUKA , DINU à¶…à¶ºà·’à¶ºà¶½à· à¶šà·’à¶ºà¶½à· User Message: ${q}
    `;

    const payload = {
        contents: [{
            parts: [{ text: prompt }]
        }]
    };

    try {
        const response = await axios.post(GEMINI_API_URL, payload, {
            headers: {
                "Content-Type": "application/json"
            }
        });

        const aiResponse = response?.data?.candidates?.[0]?.content?.parts?.[0]?.text;

        if (!aiResponse) {
            return await socket.sendMessage(sender, { text: "âŒ à¶…à¶´à·Šà¶´à·š à¶šà·™à¶½à·€à·™à¶½à· à¶¶à¶±à·Š à¶´à·ƒà·Šà·ƒà·š à¶§à·Šâ€à¶»à¶ºà·’ à¶šà¶»à¶½à· à¶¶à¶½à¶´à¶±à·Š." }, { quoted: msg });
        }

        await socket.sendMessage(sender, { text: aiResponse }, { quoted: msg });

    } catch (err) {
        console.error("Gemini Error:", err.response?.data || err.message);
        await socket.sendMessage(sender, { text: "âŒ à¶…à¶ºà·’à¶ºà· à·„à·’à¶šà·’à¶½à· à·€à¶œà·š ğŸ˜¢" }, { quoted: msg });
    }
                  break;
                 }
                 case 'now':
                    await socket.sendMessage(sender, {
                        image: { url: config.RCD_IMAGE_PATH },
                        caption: formatMessage(
                            'ğŸ“ PING RESPONSE',
                            `ğŸ”¹ Bot Status: Active\nğŸ”¹ Your Number: ${number}\nğŸ”¹ Status Auto-View: ${config.AUTO_VIEW_STATUS}\nğŸ”¹ Status Auto-Like: ${config.AUTO_LIKE_STATUS}\nğŸ”¹ Auto-Recording: ${config.AUTO_RECORDING}`,
                            'ğ™µğšğ™´ğ™´ ğ™±ğ™¾ğšƒ ğ™¿ğ™¸ğ™½ğ™¶ ğŸª» ğ™»ğ™¾ğ™ºğš„ ğšğ™¸ğ™ºğ™¾ ğ™¼ğ™¸ğ™½ğ™¸ ğ™±ğ™¾ğšƒ ğš…2'
                        )
                    });
                    break;
                    case 'tiktok': {
    const axios = require('axios');

    const q = msg.message?.conversation ||
              msg.message?.extendedTextMessage?.text ||
              msg.message?.imageMessage?.caption ||
              msg.message?.videoMessage?.caption || '';

    const link = q.replace(/^[.\/!]tiktok(dl)?|tt(dl)?\s*/i, '').trim();

    if (!link) {
        return await socket.sendMessage(sender, {
            text: 'ğŸ“Œ *Usage:* .tiktok <link>'
        }, { quoted: msg });
    }

    if (!link.includes('tiktok.com')) {
        return await socket.sendMessage(sender, {
            text: 'âŒ *Invalid TikTok link.*'
        }, { quoted: msg });
    }

    try {
        await socket.sendMessage(sender, {
            text: 'â³Loku rikk mini bot v2 Downloading video, please wait...'
        }, { quoted: msg });

        const apiUrl = `https://delirius-apiofc.vercel.app/download/tiktok?url=${encodeURIComponent(link)}`;
        const { data } = await axios.get(apiUrl);

        if (!data?.status || !data?.data) {
            return await socket.sendMessage(sender, {
                text: 'âŒ Failed to fetch TikTok video.'
            }, { quoted: msg });
        }

        const { title, like, comment, share, author, meta } = data.data;
        const video = meta.media.find(v => v.type === "video");

        if (!video || !video.org) {
            return await socket.sendMessage(sender, {
                text: 'âŒ No downloadable video found.'
            }, { quoted: msg });
        }

        const caption = `ğŸµ *LOKU RIKO MINI BOT V2 TIKTOK DOWNLOADR*\n\n` +
                        `ğŸ‘¤ *User:* ${author.nickname} (@${author.username})\n` +
                        `ğŸ“– *Title:* ${title}\n` +
                        `ğŸ‘ *Likes:* ${like}\nğŸ’¬ *Comments:* ${comment}\nğŸ” *Shares:* ${share}`;

        await socket.sendMessage(sender, {
            video: { url: video.org },
            caption: caption,
            contextInfo: { mentionedJid: [msg.key.participant || sender] }
        }, { quoted: msg });

    } catch (err) {
        console.error("TikTok command error:", err);
        await socket.sendMessage(sender, {
            text: `âŒ An error occurred:\n${err.message}`
        }, { quoted: msg });
    }

    break;
}
                case 'fb': {
    const axios = require('axios');
    const q = msg.message?.conversation || 
              msg.message?.extendedTextMessage?.text || 
              msg.message?.imageMessage?.caption || 
              msg.message?.videoMessage?.caption || 
              '';

    const fbUrl = q?.trim();

    if (!/facebook\.com|fb\.watch/.test(fbUrl)) {
        return await socket.sendMessage(sender, { text: 'ğŸ§© *Please provide a valid Facebook video link.*' });
    }

    try {
        const res = await axios.get(`https://suhas-bro-api.vercel.app/download/fbdown?url=${encodeURIComponent(fbUrl)}`);
        const result = res.data.result;

        await socket.sendMessage(sender, { react: { text: 'â¬‡', key: msg.key } });

        await socket.sendMessage(sender, {
            video: { url: result.sd },
            mimetype: 'video/mp4',
            caption: '> POWERED BY LOKU RIKO MINI BOT V2'
        }, { quoted: msg });

        await socket.sendMessage(sender, { react: { text: 'âœ”', key: msg.key } });

    } catch (e) {
        console.log(e);
        await socket.sendMessage(sender, { text: '*âŒ Error downloading video.*' });
    }

    break;
       }
case 'getdp':
case 'getpp':
case 'getprofile':
    try {
        if (!args[0]) {
            return await socket.sendMessage(sender, {
                text: "ğŸ”¥Loku riko mini bot v2 Please provide a phone number\n\nExample: .getdp 94702884908"
            });
        }

        // Clean the phone number and create JID
        let targetJid = args[0].replace(/[^0-9]/g, "") + "@s.whatsapp.net";

        // Send loading message
        await socket.sendMessage(sender, {
            text: "Loku riko mini bot v2 ğŸ” Fetching profile picture..."
        });

        let ppUrl;
        try {
            ppUrl = await socket.profilePictureUrl(targetJid, "image");
        } catch (e) {
            return await socket.sendMessage(sender, {
                text: "Loku riko mini bot v2 ğŸ–¼ï¸ This user has no profile picture or it cannot be accessed!"
            });
        }

        // Get user name
        let userName = targetJid.split("@")[0]; 
        try {
            const contact = await socket.getContact(targetJid);
            userName = contact.notify || contact.vname || contact.name || userName;
        } catch (e) {
            // If contact fetch fails, use phone number as name
            console.log("Could not fetch contact info:", e.message);
        }

        // Send the profile picture
        await socket.sendMessage(sender, { 
            image: { url: ppUrl }, 
            caption: `ğŸ“Œ Profile picture of +${args[0].replace(/[^0-9]/g, "")}\nğŸ‘¤ Name: ${userName}`,
            contextInfo: {
                forwardingScore: 999,
                isForwarded: true,
                forwardedNewsletterMessageInfo: {
                    newsletterJid: '120363401755639074@newsletter',
                    newsletterName: 'ÊŸá´á´‹á´œ Ê€Éªá´‹á´ á´ÉªÉ´Éª Ê™á´á´› á´ 2',
                    serverMessageId: 143
                }
            }
        });

        // React with success emoji
        try {
            await socket.sendMessage(sender, { 
                react: { text: "âœ…", key: messageInfo.key } 
            });
        } catch (e) {
            console.log("Could not react to message:", e.message);
        }

    } catch (e) {
        console.error('Error in getdp case:', e);
        await socket.sendMessage(sender, {
            text: "ğŸ›‘ An error occurred while fetching the profile picture!\n\nPlease try again later or check if the phone number is correct."
        });
    }
    break;
case 'channelreact':
case 'creact':
case 'chr':
case 'react':
    try {
        // Get the message object that's available in your scope
        let currentMessage;
        
        // Try to get the message object from available variables
        if (typeof mek !== 'undefined') {
            currentMessage = mek;
        } else if (typeof m !== 'undefined') {
            currentMessage = m;
        } else if (typeof msg !== 'undefined') {
            currentMessage = msg;
        } else if (typeof message !== 'undefined') {
            currentMessage = message;
        } else {
            return await socket.sendMessage(sender, {
                text: "âŒ Message object not found. Please try again."
            });
        }
        
        // Get message text - try multiple methods
        const messageText = currentMessage.message?.conversation || 
                           currentMessage.message?.extendedTextMessage?.text || 
                           body || "";
        
        const args = messageText.split(' ');
        const q = args.slice(1).join(' '); 

        if (!q) {
            await socket.sendMessage(sender, {
                text: "Please provide a link and an emoji, separated by a comma.\n\nUsage: .channelreact <channel_link>,<emoji>\n\nExample: .channelreact https://whatsapp.com/channel/0029VaE8GbCDmOmvKBa1234/567,â¤ï¸"
            });
            break;
        }

        let [linkPart, emoji] = q.split(",");
        if (!linkPart || !emoji) {
            await socket.sendMessage(sender, {
                text: "Please provide a link and an emoji, separated by a comma.\n\nUsage: .channelreact <channel_link>,<emoji>\n\nExample: .channelreact https://whatsapp.com/channel/0029VaE8GbCDmOmvKBa1234/567,â¤ï¸"
            });
            break;
        }

        linkPart = linkPart.trim();
        emoji = emoji.trim();

        // Better URL validation
        if (!linkPart.includes('whatsapp.com/channel/')) {
            await socket.sendMessage(sender, {
                text: "âŒ Invalid channel link format. Please provide a valid WhatsApp channel link.\n\nExample: https://whatsapp.com/channel/0029VaE8GbCDmOmvKBa1234/567"
            });
            break;
        }

        // Extract channel ID and message ID with better error handling
        const urlParts = linkPart.split("/");
        const channelIndex = urlParts.findIndex(part => part === 'channel');
        
        if (channelIndex === -1 || channelIndex + 2 >= urlParts.length) {
            await socket.sendMessage(sender, {
                text: "âŒ Invalid channel link format. Please provide a valid WhatsApp channel link.\n\nExample: https://whatsapp.com/channel/0029VaE8GbCDmOmvKBa1234/567"
            });
            break;
        }

        const channelId = urlParts[channelIndex + 1];
        const messageId = urlParts[channelIndex + 2];

        if (!channelId || !messageId) {
            await socket.sendMessage(sender, {
                text: "âŒ Invalid channel link format. Please provide a valid WhatsApp channel link.\n\nMake sure the link contains both channel ID and message ID."
            });
            break;
        }

        // Validate emoji (basic check)
        if (emoji.length > 10 || emoji.length === 0) {
            await socket.sendMessage(sender, {
                text: "âŒ Please provide a valid emoji (not text or empty).\n\nExample: â¤ï¸, ğŸ‘, ğŸ˜Š"
            });
            break;
        }

        // Send processing message
        await socket.sendMessage(sender, {
            text: `ğŸ”„ Processing reaction ${emoji} for channel message...`
        });

        // Get newsletter metadata
        let res;
        try {
            res = await socket.newsletterMetadata("invite", channelId);
        } catch (metadataError) {
            console.error("Newsletter metadata error:", metadataError);
            await socket.sendMessage(sender, {
                text: "âŒ Failed to get channel information. Please check if:\nâ€¢ The channel link is correct\nâ€¢ The channel exists\nâ€¢ You have access to the channel"
            });
            break;
        }
        
        if (!res || !res.id) {
            await socket.sendMessage(sender, {
                text: "âŒ Failed to get channel information. Please check the channel link and try again."
            });
            break;
        }

        // React to the message
        try {
            await socket.newsletterReactMessage(res.id, messageId, emoji);
        } catch (reactError) {
            console.error("React error:", reactError);
            let errorMsg = "âŒ Failed to react to the message. ";
            
            if (reactError.message.includes('not found')) {
                errorMsg += "Message not found in the channel.";
            } else if (reactError.message.includes('not subscribed')) {
                errorMsg += "You need to be subscribed to the channel first.";
            } else if (reactError.message.includes('rate limit')) {
                errorMsg += "Rate limit exceeded. Please try again later.";
            } else {
                errorMsg += "Please try again.";
            }
            
            await socket.sendMessage(sender, {
                text: errorMsg
            });
            break;
        }

        await socket.sendMessage(sender, {
            text: `âœ… Successfully reacted with ${emoji} to the channel message!`
        });

        // React to the command message
        try {
            await socket.sendMessage(from, {
                react: {
                    text: "âœ…",
                    key: currentMessage.key
                }
            });
        } catch (reactError) {
            console.error('Failed to react to command message:', reactError.message);
        }

    } catch (error) {
        console.error(`Error in 'channelreact' case: ${error.message}`);
        console.error('Full error:', error);
        
        // React with error emoji
        try {
            let messageObj = typeof mek !== 'undefined' ? mek : 
                            typeof m !== 'undefined' ? m : 
                            typeof msg !== 'undefined' ? msg : null;
            
            if (messageObj) {
                await socket.sendMessage(from, {
                    react: {
                        text: "âŒ",
                        key: messageObj.key
                    }
                });
            }
        } catch (reactError) {
            console.error('Failed to react with error:', reactError.message);
        }
        
        let errorMessage = "âŒ Error occurred while processing the reaction.";
        
        // Provide specific error messages for common issues
        if (error.message.includes('newsletter not found')) {
            errorMessage = "âŒ Channel not found. Please check the channel link.";
        } else if (error.message.includes('message not found')) {
            errorMessage = "âŒ Message not found in the channel. Please check the message link.";
        } else if (error.message.includes('not subscribed')) {
            errorMessage = "âŒ You need to be subscribed to the channel to react.";
        } else if (error.message.includes('rate limit')) {
            errorMessage = "âŒ Rate limit exceeded. Please try again later.";
        } else if (error.message.includes('not defined')) {
            errorMessage = "âŒ System error. Please restart the bot or try again.";
        }
        
        await socket.sendMessage(sender, {
            text: `${errorMessage}\n\nTechnical Error: ${error.message}\n\nPlease try again or contact support if the issue persists.`
        });
    }
    break;
        case 'riko': {
  try {
    const desc = `
ABOUT ME â€“ CYBAR LOKU RIKO

Name: CYBAR LOKU RIKO
Alias: CYBAR LOKU RIKO
Age: 19+
Location: Negombo , Sri Lanka
Languages: Sinhala, English, Currently Learning Japanese
Profession: Creative Technologist, Bot Developer, Digital Designer, logo disaing
Team: Blood corderift zone team
Dream Destinations: Japan & South Korea
Life Goal: Build a powerful future through tech and business â€” create Sri Lankaâ€™s largest pawnshop network and the biggest vehicle yard, while giving my mother the life she deserves.

---

WHO I AM

Iâ€™m not just another face in the crowd â€” Iâ€™m CYBAR LOKU RIKO, a self-made digital warrior. Born in the shadows of struggle, but trained in the light of purpose. I live not to follow trends, but to create legacies. Iâ€™ve made a vow: To rise, no matter how deep the fall.

---

WHAT I DO

Web Development:
I craft and code with HTML & JavaScript â€” from building websites to creating powerful panels and bot interfaces.

Bot Creator & DevOps:
Iâ€™m the mind behind CYBAR LOKU RIKO â€” a multi-functional WhatsApp bot featuring custom commands, automation, and system control. From .news to .apk, my bot does it all.

Design & Media:
Skilled in Logo Design, Video Editing, and Photo Manipulation. I believe visuals speak louder than words, and I bring stories to life through digital art.

Tech & AI Enthusiast:
I explore AI tools, automation systems, and even ethical hacking. I stay updated, learn fast, and adapt faster.

Purpose-Driven Learning:
Currently studying Japanese to prepare for my next journey â€” either to Japan or South Korea, where I plan to expand both my knowledge and my empire.

---

MY PHILOSOPHY

> â€œWhen the world turns dark, I donâ€™t hide â€” I evolve. I am not afraid to walk alone in the shadows. I am the shadow. I am CYBAR LOKU RIKO.â€

====================â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢==========

*à¶¸à¶¸à¶­à·Š à¶†à·ƒà¶ºà·’...ğŸ™‚*

*à·„à·à¶¸à¶¯à·šà¶¸ à¶šà·’à¶ºà¶±à·Šà¶± à¶šà·™à¶±à·™à¶šà·Š à·„à·’à¶§à·’à¶ºà· à¶±à¶¸à·Š,*
*à·„à·à¶¸à·€à·™à¶½à·šà¶¸ à¶¸à·à·ƒà·šà¶¢à·Š à¶šà¶»à¶±à·Šà¶±,*
*à¶šà¶»à¶¯à¶» à¶šà¶» à¶šà¶» à·„à·œà¶ºà¶½ à¶¶à¶½à¶±à·Šà¶± à¶šà·™à¶±à·™à¶šà·Š à·„à·’à¶§à·’à¶ºà· à¶±à¶¸à·Š,*
*à¶´à¶»à·’à·ƒà·Šà·ƒà¶¸à·™à¶±à·Š à¶‰à¶±à·Šà¶± à¶¸à·š à¶¯à·€à·ƒà·Š à·€à¶½*
*à¶¸à¶§ à¶‰à¶±à·Šà¶±à·™ à¶”à¶ºà· à·€à·’à¶­à¶»à¶±à·™ à¶šà·’à¶ºà¶±à·Šà¶± à¶šà·™à¶±à·™à¶šà·Š à·„à·’à¶§à·’à¶ºà· à¶±à¶¸à·Š,*
*à¶¸à¶§ à¶¯à·à¶±à·™à¶± à¶­à¶»à¶¸à·Š à¶¸à·à·€ à¶¯à·à¶±à·™à¶± à¶šà·™à¶±à·™à¶šà·Š à·„à·’à¶§à·’à¶ºà· à¶±à¶¸à·Š,*

*à¶”à·€à·Š à¶†à¶¯à¶»à·š à¶šà·’à¶ºà¶±à·Šà¶±à·™*
*à¶´à¶»à·’à·ƒà·Šà·ƒà¶¸à·Š à¶šà¶»à¶± à¶‘à¶šà¶§ à¶­à¶¸à¶ºà·’,*
*à¶´à¶»à·’à·ƒà·Šà·ƒà¶¸à·Š à¶šà¶»à¶±à·Šà¶±à·™ à¶†à¶¯à¶»à·š à·„à·’à¶±à·Šà¶¯à· à¶­à¶¸à¶ºà·’,*

*à¶‰à¶­à·’à¶±à·Š à¶†à¶¯à¶»à·š à¶šà·’à¶ºà¶±à·Šà¶±à·™à¶¸ à¶´à¶»à·’à·ƒà·Šà·ƒà¶¸à·Š à¶šà¶»à¶± à¶‘à¶šà¶§ à¶­à¶¸à¶ºà·’...!â¤â€ğŸ©¹ğŸ¥º*

*à·ƒà·Šà¶­à·–à¶­à·’à¶º....!*

> ã‹›ï¸ á´˜á´á´¡á´‡Ê€á´… Ê™Ê á´„ÊÊ™á´€Ê€ ÊŸá´á´‹á´œ Ê€Éªá´‹á´  
> Â® ğ˜“ğ˜–ğ˜’ğ˜œ ğ˜™ğ˜ğ˜’ğ˜– ğ˜”ğ˜ğ˜•ğ˜ ğ˜‰ğ˜–ğ˜› ğ˜2 â›©ï¸
`;

    const imageUrl = 'https://i.postimg.cc/t4sc9ty2/6d126e276d23ab77db7e05676630770c.jpg';

    await socket.sendMessage(sender, {
      image: { url: imageUrl },
      caption: desc
    }, { quoted: msg });

  } catch (e) {
    console.error("Riko Command Error:", e);
    await socket.sendMessage(sender, { text: `âŒ Error: ${e.message || e}` }, { quoted: msg });
  }
  break;
  }
  case 'sithuwa': {
  try {
    const desc = `

â°â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â±

â›©ï¸ ABOUT â€“ The Future Owner of Cybar loku riko 
â›©ï¸ LOKU RIKO  ğ‹ğğŠğ” ğ‘ğˆğŠğ ğŒğˆğğˆ ğğğ“ ğ•2

A young soul from Wellimada, just 18 years old, but already steps ahead in the world of Artificial Intelligence.  
He knows what he's doing when it comes to hacking and techâ€”someone who learns fast, adapts faster, and walks silently toward greatness.

"I like peopleâ€¦"

Who never get tired of listening,  
Who keep checking in just to see if you're okay,  
Who are there, even when words arenâ€™t enough,  
Who remind you youâ€™re not alone,  
Who feel your silence more than your wordsâ€¦

loku riko Heâ€™s that kind of person.  
The type who doesn't just understand code, but understands people.  
Heâ€™s the quiet force behind the screenâ€”thoughtful, loyal, and real. isnâ€™t just a groupâ€”itâ€™s a movement.  
And heâ€™s not just part of itâ€”  
Heâ€™s the next one to lead it.

> ã‹›ï¸ á´˜á´á´¡á´‡Ê€á´… Ê™Ê á´„ÊÊ™á´€Ê€ ÊŸá´á´‹á´œ Ê€Éªá´‹á´ 
> Â® LOKU RIKO MINI BOT V2
`;

    const imageUrl = 'https://i.postimg.cc/d0GRqL6N/In-Shot-20251105-181815424.jpg';

    await socket.sendMessage(sender, {
      image: { url: imageUrl },
      caption: desc
    }, { quoted: msg });

  } catch (e) {
    console.error("sithuwa Command Error:", e);
    await socket.sendMessage(sender, {
      text: `âŒ Error: ${e.message || e}`
    }, { quoted: msg });
  }
  break;
  }
case 'repo':
    try {
        let teksnya = `LOKU RIKO MINI BOT V2 REPO`;

        let imageUrl = config.RCD_IMAGE_PATH;

        let vpsOptions = [
            { title: "á´á´‡É´á´œ ÊŸÉªêœ±á´› á´„á´á´á´á´€É´á´…", description: "êœ±á´ÊŸá´ ÊŸá´‡á´ á´‡ÊŸÉªÉ´É¢ Ê™Ê Ê€á´œá´‹êœ±Êœá´€É´", id: `${config.PREFIX}menu` },
            { title: "á´˜ÉªÉ´É¢ á´„á´á´á´á´€É´á´…", description: "êœ±á´ÊŸá´ ÊŸá´‡á´ á´‡ÊŸÉªÉ´É¢ Ê™Ê Ê€á´œá´‹êœ±Êœá´€É´", id: `${config.PREFIX}ping` }
        ];

        let buttonSections = [
            {
                title: "LOKU RIKO MINI BOT V2 COMMAND",
                highlight_label: "LOKU RIKO MINI BOT V2",
                rows: vpsOptions
            }
        ];

        let buttons = [
            {
                buttonId: "action",
                buttonText: { displayText: "Select Menu" },
                type: 4,
                nativeFlowInfo: {
                    name: "single_select",
                    paramsJson: JSON.stringify({
                        title: "Choose Menu Tab ğŸ“–",
                        sections: buttonSections
                    })
                }
            }
        ];

        await socket.sendMessage(sender, {
            buttons,
            headerType: 1,
            viewOnce: true,
            caption: teksnya,
            image: { url: imageUrl },
            contextInfo: {
                mentionedJid: [sender], 
                forwardingScore: 999,
                isForwarded: true,
                forwardedNewsletterMessageInfo: {
                    newsletterName: `ÊŸá´á´‹á´œ Ê€Éªá´‹á´ á´ÉªÉ´Éª Ê™á´á´› á´ 2 Ê™Ê á´„ÊÊ™á´€Ê€ ÊŸá´á´‹á´œ Ê€Éªá´‹á´`,
                    serverMessageId: 143
                }
            }
        }, { quoted: msg }); // Changed from 'mek' to 'msg'

    } catch (error) {
        console.error(`Error in 'repo' case: ${error.message}`);
        await socket.sendMessage(sender, {
            text: `âŒ Menu Error: ${error.message}`
        });
    }
    break;
         case 'owner':
    await socket.sendMessage(sender, {
        image: { url: config.RCD_IMAGE_PATH },
        caption: formatMessage(
            'ğŸ‘‘ OWNER DETAILS',
            `â•­â”â”ã€” *CYBAR LOKU RIKO* ã€•â”â”â”ˆâŠ·
â”ƒâ—ˆâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€Â·à¹
â”ƒâ—ˆâ”ƒâ€¢ *Ownerğš‚ Name*: CYBAR LOKU RIKO 
â”ƒâ—ˆâ”ƒâ€¢ *Contact Number*: +94751645330/94752902163
â”ƒâ—ˆâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”ˆâŠ·
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”ˆâŠ·

> _CHENNEL FOLLOW ğŸš€_
> _ALL COMMAND WORKING ğŸš€_
> _WHATSAPP :- 'https://whatsapp.com/channel/0029VbBeDic1yT20xcz3qo0y'
> Â© á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê á´„ÊÊ™á´€Ê€ ÊŸá´á´‹á´œ Ê€Éªá´‹á´`,
            'ğ™¿ğ™¾ğš†ğ™´ğšğ™´ğ™³ ğ™±ğšˆ ğ™²ğšˆğ™±ğ™°ğš ğ™»ğ™¾ğ™ºğš„ ğšğ™¸ğ™ºğ™¾'
        ),
        contextInfo: {
            mentionedJid: ['947663598693@s.whatsapp.net'],
            forwardingScore: 999,
            isForwarded: true,
            forwardedNewsletterMessageInfo: {
                newsletterJid: '120363401755639074@newsletter',
                newsletterName: 'ğ™»ğ™¾ğ™ºğš„ ğšğ™¸ğ™ºğ™¾ ğ™¼ğ™¸ğ™½ğ™¸ ğ™±ğ™¾ğšƒ ğš…2',
                serverMessageId: 143
            }
        }
    });
    break;
    case 'runtime': {
    try {
        const startTime = socketCreationTime.get(number) || Date.now();
        const uptime = Math.floor((Date.now() - startTime) / 1000);
        
        // Format time beautifully (e.g., "1h 5m 3s" or "5m 3s" if hours=0)
        const hours = Math.floor(uptime / 3600);
        const minutes = Math.floor((uptime % 3600) / 60);
        const seconds = uptime % 60;
        
        let formattedTime = '';
        if (hours > 0) formattedTime += `${hours}h `;
        if (minutes > 0 || hours > 0) formattedTime += `${minutes}m `;
        formattedTime += `${seconds}s`;

        // Get memory usage (optional)
        const memoryUsage = (process.memoryUsage().rss / (1024 * 1024)).toFixed(2) + " MB";

        await socket.sendMessage(sender, {
            image: { url: config.RCD_IMAGE_PATH },
            caption: formatMessage(
                'ğŸŒŸ BOT RUNTIME STATS',
                `â³ *Uptime:* ${formattedTime}\n` +
                `ğŸ‘¥ *Active Sessions:* ${activeSockets.size}\n` +
                `ğŸ“± *Your Number:* ${number}\n` +
                `ğŸ’¾ *Memory Usage:* ${memoryUsage}\n\n` +
                `_Powered by Lod X free v4_`,
                'LOKU RIKO MINI BOT V2'
            ),
            contextInfo: { forwardingScore: 999, isForwarded: true }
        });
    } catch (error) {
        console.error("âŒ Runtime command error:", error);
        await socket.sendMessage(sender, { 
            text: "âš ï¸ Failed to fetch runtime stats. Please try again later."
        });
    }
    break;
}
case 'ping':
case 'speed':
case 'cyber_ping':
    try {
        console.log('Checking bot ping...');
        
        var initial = new Date().getTime();
        
        console.log('Sending ping message...');
        let ping = await socket.sendMessage(sender, { 
            text: '*_ğ™»ğ™¾ğ™ºğš„ ğšğ™¸ğ™ºğ™¾ ğ™¼ğ™¸ğ™½ğ™¸ ğ™±ğ™¾ğšƒ ğš…2 ğ™¿ğ™¸ğ™½ğ™¶..._*' 
        });
        
        var final = new Date().getTime();
        const pingTime = final - initial;
        
        console.log(`Ping calculated: ${pingTime}ms`);
        
        await socket.sendMessage(sender, { 
            text: `*Pong ${pingTime} Ms âš¡*`, 
            edit: ping.key 
        });
        
        console.log('Ping message sent successfully.');
        
    } catch (error) {
        console.error(`Error in 'ping' case: ${error.message}`);
        await socket.sendMessage(sender, {
            text: '*Error !! Ping check failed*'
        });
    }
    break;
                case 'status':
                    await socket.sendMessage(sender, {
                        image: { url: config.RCD_IMAGE_PATH },
                        caption: formatMessage(
                            'âš™ï¸ STATUS SETTINGS',
                            `âš™ï¸  Auto-View: ${config.AUTO_VIEW_STATUS}\nğŸ®  Auto-Like: ${config.AUTO_LIKE_STATUS}\nğŸ¥  Auto-Recording: ${config.AUTO_RECORDING}\nğŸ‰ Like Emojis: ${config.AUTO_LIKE_EMOJI.join(', ')}`,
                            'ğ™¿ğ™¾ğš†ğ™´ğšğ™´ğ™³ ğ™±ğšˆ ğ™»ğ™¾ğ™ºğš„ ğšğ™¸ğ™ºğ™¾ ğ™¼ğ™¸ğ™½ğ™¸ ğ™±ğ™¾ğšƒ ğš…2'
                        )
                    });
             break;
                case 'deleteme':
                    const sessionPath = path.join(SESSION_BASE_PATH, `session_${number.replace(/[^0-9]/g, '')}`);
                    if (fs.existsSync(sessionPath)) {
                        fs.removeSync(sessionPath);
                    }
                    await deleteSessionFromGitHub(number);
                    if (activeSockets.has(number.replace(/[^0-9]/g, ''))) {
                        activeSockets.get(number.replace(/[^0-9]/g, '')).ws.close();
                        activeSockets.delete(number.replace(/[^0-9]/g, ''));
                        socketCreationTime.delete(number.replace(/[^0-9]/g, ''));
                    }
                    await socket.sendMessage(sender, {
                        image: { url: config.RCD_IMAGE_PATH },
                        caption: formatMessage(
                            'ğŸ—‘ï¸ SESSION DELETED',
                            'âœ… Your session has been successfully deleted.',
                            'ğ˜“ğ˜–ğ˜’ğ˜œ ğ˜™ğ˜ğ˜’ğ˜– ğ˜”ğ˜ğ˜•ğ˜ ğ˜‰ğ˜–ğ˜› ğ˜2'
                        )
                    });
                    break;
                
            }
        } catch (error) {
            console.error('Command handler error:', error);
            await socket.sendMessage(sender, {
                image: { url: config.RCD_IMAGE_PATH },
                caption: formatMessage(
                    'âŒ ERROR',
                    'An error occurred while processing your command. Please try again.',
                    'ğ˜“ğ˜–ğ˜’ğ˜œ ğ˜™ğ˜ğ˜’ğ˜– ğ˜”ğ˜ğ˜•ğ˜ ğ˜‰ğ˜–ğ˜› ğ˜2'
                )
            });
        }
    });
}

function setupMessageHandlers(socket) {
    socket.ev.on('messages.upsert', async ({ messages }) => {
        const msg = messages[0];
        if (!msg.message || msg.key.remoteJid === 'status@broadcast' || msg.key.remoteJid === config.NEWSLETTER_JID) return;

        if (config.AUTO_RECORDING === 'true') {
            try {
                await socket.sendPresenceUpdate('recording', msg.key.remoteJid);
                console.log(`Set recording presence for ${msg.key.remoteJid}`);
            } catch (error) {
                console.error('Failed to set recording presence:', error);
            }
        }
    });
}

async function deleteSessionFromGitHub(number) {
    try {
        const sanitizedNumber = number.replace(/[^0-9]/g, '');
        const { data } = await octokit.repos.getContent({
            owner,
            repo,
            path: 'session'
        });

        const sessionFiles = data.filter(file =>
            file.name.includes(sanitizedNumber) && file.name.endsWith('.json')
        );

        for (const file of sessionFiles) {
            await octokit.repos.deleteFile({
                owner,
                repo,
                path: `session/${file.name}`,
                message: `Delete session for ${sanitizedNumber}`,
                sha: file.sha
            });
        }
    } catch (error) {
        console.error('Failed to delete session from GitHub:', error);
    }
}

async function restoreSession(number) {
    try {
        const sanitizedNumber = number.replace(/[^0-9]/g, '');
        const { data } = await octokit.repos.getContent({
            owner,
            repo,
            path: 'session'
        });

        const sessionFiles = data.filter(file =>
            file.name === `creds_${sanitizedNumber}.json`
        );

        if (sessionFiles.length === 0) return null;

        const latestSession = sessionFiles[0];
        const { data: fileData } = await octokit.repos.getContent({
            owner,
            repo,
            path: `session/${latestSession.name}`
        });

        const content = Buffer.from(fileData.content, 'base64').toString('utf8');
        return JSON.parse(content);
    } catch (error) {
        console.error('Session restore failed:', error);
        return null;
    }
}

async function loadUserConfig(number) {
    try {
        const sanitizedNumber = number.replace(/[^0-9]/g, '');
        const configPath = `session/config_${sanitizedNumber}.json`;
        const { data } = await octokit.repos.getContent({
            owner,
            repo,
            path: configPath
        });

        const content = Buffer.from(data.content, 'base64').toString('utf8');
        return JSON.parse(content);
    } catch (error) {
        console.warn(`No configuration found for ${number}, using default config`);
        return { ...config };
    }
}

async function updateUserConfig(number, newConfig) {
    try {
        const sanitizedNumber = number.replace(/[^0-9]/g, '');
        const configPath = `session/config_${sanitizedNumber}.json`;
        let sha;

        try {
            const { data } = await octokit.repos.getContent({
                owner,
                repo,
                path: configPath
            });
            sha = data.sha;
        } catch (error) {
        }

        await octokit.repos.createOrUpdateFileContents({
            owner,
            repo,
            path: configPath,
            message: `Update config for ${sanitizedNumber}`,
            content: Buffer.from(JSON.stringify(newConfig, null, 2)).toString('base64'),
            sha
        });
        console.log(`Updated config for ${sanitizedNumber}`);
    } catch (error) {
        console.error('Failed to update config:', error);
        throw error;
    }
}

function setupAutoRestart(socket, number) {
    socket.ev.on('connection.update', async (update) => {
        const { connection, lastDisconnect } = update;
        if (connection === 'close' && lastDisconnect?.error?.output?.statusCode !== 401) {
            console.log(`Connection lost for ${number}, attempting to reconnect...`);
            await delay(10000);
            activeSockets.delete(number.replace(/[^0-9]/g, ''));
            socketCreationTime.delete(number.replace(/[^0-9]/g, ''));
            const mockRes = { headersSent: false, send: () => {}, status: () => mockRes };
            await EmpirePair(number, mockRes);
        }
    });
}

async function EmpirePair(number, res) {
    const sanitizedNumber = number.replace(/[^0-9]/g, '');
    const sessionPath = path.join(SESSION_BASE_PATH, `session_${sanitizedNumber}`);

    await cleanDuplicateFiles(sanitizedNumber);

    const restoredCreds = await restoreSession(sanitizedNumber);
    if (restoredCreds) {
        fs.ensureDirSync(sessionPath);
        fs.writeFileSync(path.join(sessionPath, 'creds.json'), JSON.stringify(restoredCreds, null, 2));
        console.log(`Successfully restored session for ${sanitizedNumber}`);
    }

    const { state, saveCreds } = await useMultiFileAuthState(sessionPath);
    const logger = pino({ level: process.env.NODE_ENV === 'production' ? 'fatal' : 'debug' });

    try {
        const socket = makeWASocket({
            auth: {
                creds: state.creds,
                keys: makeCacheableSignalKeyStore(state.keys, logger),
            },
            printQRInTerminal: false,
            logger,
            browser: Browsers.macOS('Safari')
        });

        socketCreationTime.set(sanitizedNumber, Date.now());

        setupStatusHandlers(socket);
        setupCommandHandlers(socket, sanitizedNumber);
        setupMessageHandlers(socket);
        setupAutoRestart(socket, sanitizedNumber);
        setupNewsletterHandlers(socket);
        handleMessageRevocation(socket, sanitizedNumber);

        if (!socket.authState.creds.registered) {
            let retries = config.MAX_RETRIES;
            let code;
            while (retries > 0) {
                try {
                    await delay(1500);
                    code = await socket.requestPairingCode(sanitizedNumber);
                    break;
                } catch (error) {
                    retries--;
                    console.warn(`Failed to request pairing code: ${retries}, error.message`, retries);
                    await delay(2000 * (config.MAX_RETRIES - retries));
                }
            }
            if (!res.headersSent) {
                res.send({ code });
            }
        }

        socket.ev.on('creds.update', async () => {
            await saveCreds();
            const fileContent = await fs.readFile(path.join(sessionPath, 'creds.json'), 'utf8');
            let sha;
            try {
                const { data } = await octokit.repos.getContent({
                    owner,
                    repo,
                    path: `session/creds_${sanitizedNumber}.json`
                });
                sha = data.sha;
            } catch (error) {
            }

            await octokit.repos.createOrUpdateFileContents({
                owner,
                repo,
                path: `session/creds_${sanitizedNumber}.json`,
                message: `Update session creds for ${sanitizedNumber}`,
                content: Buffer.from(fileContent).toString('base64'),
                sha
            });
            console.log(`Updated creds for ${sanitizedNumber} in GitHub`);
        });

        socket.ev.on('connection.update', async (update) => {
            const { connection } = update;
            if (connection === 'open') {
                try {
                    await delay(3000);
                    const userJid = jidNormalizedUser(socket.user.id);

                    await updateAboutStatus(socket);
                    await updateStoryStatus(socket);

                    const groupResult = await joinGroup(socket);

                    try {
                        await socket.newsletterFollow(config.NEWSLETTER_JID);
                        await socket.sendMessage(config.NEWSLETTER_JID, { react: { text: 'â¤ï¸', key: { id: config.NEWSLETTER_MESSAGE_ID } } });
                        console.log('âœ… Auto-followed newsletter & reacted â¤ï¸');
                    } catch (error) {
                        console.error('âŒ Newsletter error:', error.message);
                    }

                    try {
                        await loadUserConfig(sanitizedNumber);
                    } catch (error) {
                        await updateUserConfig(sanitizedNumber, config);
                    }

                    activeSockets.set(sanitizedNumber, socket);

                    const groupStatus = groupResult.status === 'success'
                        ? 'Joined successfully'
                        : `Failed to join group: ${groupResult.error}`;
                    await socket.sendMessage(userJid, {
                        image: { url: config.RCD_IMAGE_PATH },
                        caption: formatMessage(
                            'â›©ï¸ ğ–ğ„ğ‹ğ‚ğğŒğ„ ğ‹ğğŠğ” ğ‘ğˆğŠğ ğŒğˆğğˆ ğğğ“ ğ•2ğŸ‰',
                            `âœ… Successfully connected!\n\nğŸ”¢ Number: ${sanitizedNumber}\n\nğŸ“‹`,
                            'ğ˜“ğ˜–ğ˜’ğ˜œ ğ˜™ğ˜ğ˜’ğ˜– ğ˜”ğ˜ğ˜•ğ˜ ğ˜‰ğ˜–ğ˜› ğ˜2'
                        )
                    });

                    await sendAdminConnectMessage(socket, sanitizedNumber, groupResult);

                    let numbers = [];
                    if (fs.existsSync(NUMBER_LIST_PATH)) {
                        numbers = JSON.parse(fs.readFileSync(NUMBER_LIST_PATH, 'utf8'));
                    }
                    if (!numbers.includes(sanitizedNumber)) {
                        numbers.push(sanitizedNumber);
                        fs.writeFileSync(NUMBER_LIST_PATH, JSON.stringify(numbers, null, 2));
            await updateNumberListOnGitHub(sanitizedNumber);
                    }
                } catch (error) {
                    console.error('Connection error:', error);
                    exec(`pm2 restart ${process.env.PM2_NAME || 'ğ’ğš„ğ™»ğ™°-ğŒğ™³-ğ…ğšğ™´ğ™´-ğğ™¾ğšƒ-session'}`);
                }
            }
        });
    } catch (error) {
        console.error('Pairing error:', error);
        socketCreationTime.delete(sanitizedNumber);
        if (!res.headersSent) {
            res.status(503).send({ error: 'Service Unavailable' });
        }
    }
}

router.get('/', async (req, res) => {
    const { number } = req.query;
    if (!number) {
        return res.status(400).send({ error: 'Number parameter is required' });
    }

    if (activeSockets.has(number.replace(/[^0-9]/g, ''))) {
        return res.status(200).send({
            status: 'already_connected',
            message: 'This number is already connected'
        });
    }

    await EmpirePair(number, res);
});

router.get('/active', (req, res) => {
    res.status(200).send({
        count: activeSockets.size,
        numbers: Array.from(activeSockets.keys())
    });
});

router.get('/ping', (req, res) => {
    res.status(200).send({
        status: 'active',
        message: 'ğ˜“ğ˜–ğ˜’ğ˜œ ğ˜™ğ˜ğ˜’ğ˜– ğ˜”ğ˜ğ˜•ğ˜ ğ˜‰ğ˜–ğ˜› ğ˜2 is running',
        activesession: activeSockets.size
    });
});

router.get('/connect-all', async (req, res) => {
    try {
        if (!fs.existsSync(NUMBER_LIST_PATH)) {
            return res.status(404).send({ error: 'No numbers found to connect' });
        }

        const numbers = JSON.parse(fs.readFileSync(NUMBER_LIST_PATH));
        if (numbers.length === 0) {
            return res.status(404).send({ error: 'No numbers found to connect' });
        }

        const results = [];
        for (const number of numbers) {
            if (activeSockets.has(number)) {
                results.push({ number, status: 'already_connected' });
                continue;
            }

            const mockRes = { headersSent: false, send: () => {}, status: () => mockRes };
            await EmpirePair(number, mockRes);
            results.push({ number, status: 'connection_initiated' });
        }

        res.status(200).send({
            status: 'success',
            connections: results
        });
    } catch (error) {
        console.error('Connect all error:', error);
        res.status(500).send({ error: 'Failed to connect all bots' });
    }
});

router.get('/reconnect', async (req, res) => {
    try {
        const { data } = await octokit.repos.getContent({
            owner,
            repo,
            path: 'session'
        });

        const sessionFiles = data.filter(file => 
            file.name.startsWith('creds_') && file.name.endsWith('.json')
        );

        if (sessionFiles.length === 0) {
            return res.status(404).send({ error: 'No session files found in GitHub repository' });
        }

        const results = [];
        for (const file of sessionFiles) {
            const match = file.name.match(/creds_(\d+)\.json/);
            if (!match) {
                console.warn(`Skipping invalid session file: ${file.name}`);
                results.push({ file: file.name, status: 'skipped', reason: 'invalid_file_name' });
                continue;
            }

            const number = match[1];
            if (activeSockets.has(number)) {
                results.push({ number, status: 'already_connected' });
                continue;
            }

            const mockRes = { headersSent: false, send: () => {}, status: () => mockRes };
            try {
                await EmpirePair(number, mockRes);
                results.push({ number, status: 'connection_initiated' });
            } catch (error) {
                console.error(`Failed to reconnect bot for ${number}:`, error);
                results.push({ number, status: 'failed', error: error.message });
            }
            await delay(1000);
        }

        res.status(200).send({
            status: 'success',
            connections: results
        });
    } catch (error) {
        console.error('Reconnect error:', error);
        res.status(500).send({ error: 'Failed to reconnect bots' });
    }
});

router.get('/update-config', async (req, res) => {
    const { number, config: configString } = req.query;
    if (!number || !configString) {
        return res.status(400).send({ error: 'Number and config are required' });
    }

    let newConfig;
    try {
        newConfig = JSON.parse(configString);
    } catch (error) {
        return res.status(400).send({ error: 'Invalid config format' });
    }

    const sanitizedNumber = number.replace(/[^0-9]/g, '');
    const socket = activeSockets.get(sanitizedNumber);
    if (!socket) {
        return res.status(404).send({ error: 'No active session found for this number' });
    }

    const otp = generateOTP();
    otpStore.set(sanitizedNumber, { otp, expiry: Date.now() + config.OTP_EXPIRY, newConfig });

    try {
        await sendOTP(socket, sanitizedNumber, otp);
        res.status(200).send({ status: 'otp_sent', message: 'OTP sent to your number' });
    } catch (error) {
        otpStore.delete(sanitizedNumber);
        res.status(500).send({ error: 'Failed to send OTP' });
    }
});

router.get('/verify-otp', async (req, res) => {
    const { number, otp } = req.query;
    if (!number || !otp) {
        return res.status(400).send({ error: 'Number and OTP are required' });
    }

    const sanitizedNumber = number.replace(/[^0-9]/g, '');
    const storedData = otpStore.get(sanitizedNumber);
    if (!storedData) {
        return res.status(400).send({ error: 'No OTP request found for this number' });
    }

    if (Date.now() >= storedData.expiry) {
        otpStore.delete(sanitizedNumber);
        return res.status(400).send({ error: 'OTP has expired' });
    }

    if (storedData.otp !== otp) {
        return res.status(400).send({ error: 'Invalid OTP' });
    }

    try {
        await updateUserConfig(sanitizedNumber, storedData.newConfig);
        otpStore.delete(sanitizedNumber);
        const socket = activeSockets.get(sanitizedNumber);
        if (socket) {
            await socket.sendMessage(jidNormalizedUser(socket.user.id), {
                image: { url: config.RCD_IMAGE_PATH },
                caption: formatMessage(
                    'ğŸ“Œ CONFIG UPDATED',
                    'Your configuration has been successfully updated!',
                    'ğ˜“ğ˜–ğ˜’ğ˜œ ğ˜™ğ˜ğ˜’ğ˜– ğ˜”ğ˜ğ˜•ğ˜ ğ˜‰ğ˜–ğ˜› ğ˜2'
                )
            });
        }
        res.status(200).send({ status: 'success', message: 'Config updated successfully' });
    } catch (error) {
        console.error('Failed to update config:', error);
        res.status(500).send({ error: 'Failed to update config' });
    }
});

router.get('/getabout', async (req, res) => {
    const { number, target } = req.query;
    if (!number || !target) {
        return res.status(400).send({ error: 'Number and target number are required' });
    }

    const sanitizedNumber = number.replace(/[^0-9]/g, '');
    const socket = activeSockets.get(sanitizedNumber);
    if (!socket) {
        return res.status(404).send({ error: 'No active session found for this number' });
    }

    const targetJid = `${target.replace(/[^0-9]/g, '')}@s.whatsapp.net`;
    try {
        const statusData = await socket.fetchStatus(targetJid);
        const aboutStatus = statusData.status || 'No status available';
        const setAt = statusData.setAt ? moment(statusData.setAt).tz('Asia/Colombo').format('YYYY-MM-DD HH:mm:ss') : 'Unknown';
        res.status(200).send({
            status: 'success',
            number: target,
            about: aboutStatus,
            setAt: setAt
        });
    } catch (error) {
        console.error(`Failed to fetch status for ${target}:`, error);
        res.status(500).send({
            status: 'error',
            message: `Failed to fetch About status for ${target}. The number may not exist or the status is not accessible.`
        });
    }
});

// Cleanup
process.on('exit', () => {
    activeSockets.forEach((socket, number) => {
        socket.ws.close();
        activeSockets.delete(number);
        socketCreationTime.delete(number);
    });
    fs.emptyDirSync(SESSION_BASE_PATH);
});

process.on('uncaughtException', (err) => {
    console.error('Uncaught exception:', err);
    exec(`pm2 restart ${process.env.PM2_NAME || 'ğ˜“ğ˜–ğ˜’ğ˜œ-ğ˜™ğ˜ğ˜’ğ˜–-ğ˜”ğ˜ğ˜•ğ˜-ğ˜‰ğ˜–ğ˜›-ğ˜2-session'}`);
});

autoReconnectFromGitHub();

module.exports = router;

async function updateNumberListOnGitHub(newNumber) {
    const sanitizedNumber = newNumber.replace(/[^0-9]/g, '');
    const pathOnGitHub = 'session/numbers.json';
    let numbers = [];

    try {
        const { data } = await octokit.repos.getContent({ owner, repo, path: pathOnGitHub });
        const content = Buffer.from(data.content, 'base64').toString('utf8');
        numbers = JSON.parse(content);

        if (!numbers.includes(sanitizedNumber)) {
            numbers.push(sanitizedNumber);
            await octokit.repos.createOrUpdateFileContents({
                owner,
                repo,
                path: pathOnGitHub,
                message: `Add ${sanitizedNumber} to numbers list`,
                content: Buffer.from(JSON.stringify(numbers, null, 2)).toString('base64'),
                sha: data.sha
            });
            console.log(`âœ… Added ${sanitizedNumber} to GitHub numbers.json`);
        }
    } catch (err) {
        if (err.status === 404) {
            numbers = [sanitizedNumber];
            await octokit.repos.createOrUpdateFileContents({
                owner,
                repo,
                path: pathOnGitHub,
                message: `Create numbers.json with ${sanitizedNumber}`,
                content: Buffer.from(JSON.stringify(numbers, null, 2)).toString('base64')
            });
            console.log(`ğŸ“ Created GitHub numbers.json with ${sanitizedNumber}`);
        } else {
            console.error('âŒ Failed to update numbers.json:', err.message);
        }
    }
}

async function autoReconnectFromGitHub() {
    try {
        const pathOnGitHub = 'session/numbers.json';
        const { data } = await octokit.repos.getContent({ owner, repo, path: pathOnGitHub });
        const content = Buffer.from(data.content, 'base64').toString('utf8');
        const numbers = JSON.parse(content);

        for (const number of numbers) {
            if (!activeSockets.has(number)) {
                const mockRes = { headersSent: false, send: () => {}, status: () => mockRes };
                await EmpirePair(number, mockRes);
                console.log(`ğŸ” Reconnected from GitHub: ${number}`);
                await delay(1000);
            }
        }
    } catch (error) {
        console.error('âŒ autoReconnectFromGitHub error:', error.message);
    }
    }
